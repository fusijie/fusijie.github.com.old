<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: git | Jacky's Blog]]></title>
  <link href="http://www.fusijie.com/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://www.fusijie.com/"/>
  <updated>2014-11-25T13:46:17+08:00</updated>
  <id>http://www.fusijie.com/</id>
  <author>
    <name><![CDATA[FuSijie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[(译)第三部分：什么是rebase?]]></title>
    <link href="http://www.fusijie.com/blog/2014/11/18/what-is-a-rebase/"/>
    <updated>2014-11-18T23:44:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2014/11/18/what-is-a-rebase</id>
    <content type="html"><![CDATA[<h3>内容提要</h3>

<ul>
<li>第一部分：<a href="http://www.fusijie.com/blog/2014/10/08/what-is-a-commit-hash/">commit hash是什么？</a></li>
<li>第二部分：<a href="http://www.fusijie.com/blog/2014/10/15/what-is-a-merge/">merge是什么？</a></li>
<li>第三部分：rebase是什么？</li>
</ul>


<p>在<a href="http://www.fusijie.com/blog/2014/10/08/what-is-a-commit-hash/">第一部分</a>中，我们讨论了什么是commit hash，其中一个很重要的特点就是commit无法被修改。hash值是根据存储在commit中的信息生成的，所以修改一个commit或者commit hash，你必须要创建一个全新的commit。我们还讨论了每一个commit存储了它的前一个commit的hash值。我们所没有讨论的是它对我们Git历史的影响。</p>

<!-- more -->


<p>实际上，commit hash是基于他们本身存储的信息生成的，而这些信息其中就包含了前一个commit的hash值，所以想修改你的commit历史基本上是不可能的。每一个commit就像是链条上的一环，紧紧连接着上一环。</p>

<p><img src="http://i.imgur.com/cXvBMnk.png" alt="" /></p>

<p>如果你有如上图一样的一条金属链，在不打断他们的前提下是不可能把前一环和后一环连接起来的。然而，在Git环境中这将会更糟。这样的类比在这里是不靠谱的，因为在一条金属链上你可以焊接一个新环来把前一环和后一环重新连接起来。但是在Git中，你无法做到这一点。</p>

<p>如果你想要在commit历史的中间删除某一个commit，那后一个commit将会指向一个不存在的commit hash。因为你无法在不改变hash的情况下来修改commit，所以你不能简单地生成一个新的commit来引用前一个commit，而后一个commit仍然引用了最原始的commit hash。</p>

<p>如果你改变了一个commit的某个属性，那生成的hash值将不再一样，后一个commit也不会引用到新的commit。结果就是你不得不去修改后一个commit来引用到新的commit hash，这同样会引起commit hash的改变，就这样一路下去直到链条的末尾。</p>

<p>这时候轮到<a href="http://git-scm.com/docs/git-rebase">rebase</a>上场了。如果你还记得<a href="http://www.fusijie.com/blog/2014/10/15/what-is-a-merge/">第二部分</a>，当我们将<code>feature1</code>分支合并到<code>master</code>分支后，有一副图展示了各个commit之间的关系。</p>

<p><img src="http://i.imgur.com/S0av3NM.png" alt="" /></p>

<p>Merge可以很好地工作，但是伴随着所有的fork和横纵交叉的commit关系，Git仓库的图形很快就会失控。下图只是一个我平时工作的Git仓库的小片段。</p>

<p><img src="http://i.imgur.com/z28Y4sX.png" alt="" /></p>

<p>如果你使用一个Git GUI软件，很有可能你也见识过类似的东西。Merge是在不同分支之间移动差异的最简单的方式，因为它避免了破坏commit历史和所引发的蛋疼。然而，一旦你对rebase的工作方式有了比较深刻的理解，你将会从中收益。举个栗子，如果我们在demo仓库中rebase <code>feature1</code>分支到<code>master</code>分支(译者注：这句话的意思是切换到<code>feature1</code>分支，执行<code>git rebase master</code>命令)，将会得到一个非常漂亮干净的历史，如图：</p>

<p><img src="http://i.imgur.com/pBvTytu.png" alt="" /></p>

<p>注意到没？现在的历史是一条直线了。Git到底是怎么做到的呢？如果你还记得的话，我们的<code>Commit 3</code>和<code>Commit 4</code>是共享<code>Commit 2</code>作为其共同父节点的，<code>Commit 3</code>引用了<code>Commit 2</code>作为其前一个commit。现在你也许会疑惑为什么看起来<code>Commit 3</code>像是将<code>Commit 4</code>作为其前一个commit。</p>

<p>还记得我刚说过的，如果想从中间打断链条，你必须从这个点上开始重现创建其之后的commit，直到结尾。没错，这实际上就是rebase做的事情。</p>

<p><img src="http://i.imgur.com/1nPXWq1.png" alt="" /></p>

<p>仔细看的话，你会发现<code>Commit 3</code>，<code>Commit 5</code>，<code>Commit 6</code>的commit hash已经全部改变了。这3个commit是在<code>feature 1</code>分支上提交的。通过将<code>feature 1</code>分支rebase操作到<code>master</code>分支上，从<code>master</code>分支分叉出来的的第一个commit开始，git重写了<code>feature 1</code>所有的commit，直到结束。它将分之上的每一个commit之间的差异存储在一个临时文件中，然后开始重写我们的分支历史。而这一次，分支是从<code>master</code>，<code>Commit 4</code>开始的。</p>

<p>Git给分支上的每一个commit创建了一个新的commit，当然跟着修改的还有commit hash值。当它创建新的commit的时候，第一个commit被改为引用到<code>master</code>分支的最新的commit（<code>Commit 4</code>），而不是原来的（<code>Commit 2</code>）了。这个重新提交你的变更作为新的commit的流程被称为“你的commits在<code>master</code>分支上的重播”。</p>

<blockquote><p>注意：不要让术语混淆。Rebase到<code>master</code>分支不会修改<code>master</code>分支本身，它的意思是你的分支commits将会紧跟着<code>master</code>分支上最新的commits（译者注：这里的<code>你的分支</code>指的是<code>feature 1</code>）。</p></blockquote>

<p><img src="http://i.imgur.com/pBvTytu.png" alt="" /></p>

<p>你会注意到上图中<code>master</code>分支仍然指向<code>Commit 4</code>，它的commit hash值是没有改变的。如果我们现在切换到<code>master</code>分支，然后把<code>feature 1</code>分支合并到<code>master</code>分支，这将不会产生一个合并commit。这仅仅是一个快进提交，意思就是git将会简单地将指向<code>master</code>分支的指针笔直地移到指向<code>feature 1</code>分支的指针位置上。</p>

<p><img src="http://i.imgur.com/rLdDgw3.png" alt="" /></p>

<p>如果不把<code>feature 1</code>分支合并到<code>master</code>分支，我们还有更多的事要做，更多的commit要提交，我们可能会再fork一个仓库。我们的下一个<code>master</code>分支的commit将会指向<code>Commit 4</code>作为它的父节点，而<code>feature 1</code>分支的第一个commit也是指向<code>Commit 4</code>作为它的父节点。为了得到一条笔直的提交历史，我们需要再切换到<code>feature1</code>分支，然后再次rebase到<code>master</code>分支。这种情况很常出现，比如你在github上提交了一个pull request然后它过期了。如果项目的维护者没有合并你 的pull request，而是在这个项目上继续做一些其他工作，那么你的pull request就需要再来一次rebase操作以获取一个干净的git历史。把你做的工作rebase到原仓库分支上才可以让这个pull request能够在合并进去的时候采用简单的快进方式。接受一个pull request只是一个简单的合并。如果在提交pull request之前就rebase了你做的工作，那么这个merge就是一个快进方式的merge，这也能保证原仓库的干净。（译者注：这里的<code>干净</code>指的是没有额外的合并信息。）</p>

<h4>危险！！！</h4>

<p>这部分内容是对rebase的使用进行一些警告，主要还是在多人协作上需要注意。因为rebase是一种改写commit的操作，所以相对比较危险，作者给出的意见是：</p>

<blockquote><p>Undoing a rebase is not easy, and often impossible so you really need to pay attention to what you&rsquo;re doing. The benefits of rebasing are great, but not if you don&rsquo;t know what you&rsquo;re doing.</p></blockquote>

<p>撤销一个rebase操作不简单，而且经常是不可能的。你必须很注意自己在干什么。rebase让人受益，当时如果你不知道你在干什么的话，别用reabse。</p>

<p>这部分内容不翻译了，有兴趣自己看原文吧。</p>

<blockquote><p>英文地址:<a href="http://codetunnel.com/merge-vs-rebase-part-3-what-is-a-rebase/">http://codetunnel.com/merge-vs-rebase-part-3-what-is-a-rebase/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(译)第二部分：什么是merge?]]></title>
    <link href="http://www.fusijie.com/blog/2014/10/15/what-is-a-merge/"/>
    <updated>2014-10-15T00:03:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2014/10/15/what-is-a-merge</id>
    <content type="html"><![CDATA[<h4>内容提要</h4>

<ul>
<li>第一部分：<a href="http://www.fusijie.com/blog/2014/10/08/what-is-a-commit-hash/">commit hash是什么？</a></li>
<li>第二部分：merge是什么？</li>
<li>第三部分：<a href="http://www.fusijie.com/blog/2014/11/18/what-is-a-rebase/">rebase是什么？</a></li>
</ul>


<p>在<a href="http://www.fusijie.com/blog/2014/10/08/what-is-a-commit-hash/">第一部分</a>我们创建了一个小的demo仓库，它拥有着一个<code>feature1</code>分支，而且这个分支已经准备好要merge到<code>master</code>分支中了。</p>

<!-- more -->


<p><img src="http://i.imgur.com/kxDIgKl.png" alt="" /></p>

<p>此时，我们可以选择merge或者rebase <code>feature1</code>分支到<code>master</code>分支。关于rebase将会在<a href="http://www.fusijie.com/blog/2014/11/18/what-is-a-rebase/">第三部分</a>进行介绍。现在我们来看一下，采用merge的方式到底发生了什么。把分支合并到一起是非常直接的。首先需要将切换到要合并进去的分支，在这里，因为我们要将<code>feature1</code>合并到<code>master</code>分支，所以需要切换到<code>master</code>分支。</p>

<p><img src="http://i.imgur.com/S0av3NM.png" alt="" /></p>

<p>我切换到<code>master</code>分支，然后将<code>feature1</code>分支合并进去。回过头来再看一下这之中发生了什么，为什么Source Tree生成的图形是这个样子的。</p>

<p>还记得<a href="http://www.fusijie.com/blog/2014/10/08/what-is-a-commit-hash/">第一部分</a>中<code>Commit 3</code>和<code>Commit 4</code>引用着同一个先前commit吗？<code>Commit 2</code>是这两个commit共同的祖先，因为<code>Commit 3</code>是在另一个分支上创建的，而<code>Commit 4</code>是在<code>master</code>分支上创建的，所以它完全不知道<code>Commit 3</code>的存在。在<code>feature1</code>上我们添加了更多的commit。<code>Commit 5</code>直接引用了<code>Commit 3</code>，因为<code>Commit 4</code>只在<code>master</code>分支上有效，<code>Commit 6</code>直接引用了<code>Commit 5</code>。</p>

<p>当我们将<code>feature1</code>合并到<code>master</code>中，它并不是通过某种方式神奇地把这些commit都移到<code>master</code>分支上。实际上，它创建了一个包含了<code>feature1</code>分支上<strong>所有的</strong>变更的全新commit。这个commit叫<code>Merge branch 'feature1'</code>，就像这样：</p>

<p><img src="http://i.imgur.com/RECAHy7.png" alt="" /></p>

<p>如果你注意到上图中的commit差异，就会看到我添加到<code>index.txt</code>中二了吧唧的这几行。你应该会注意到这几行是通过各个commit分开地添加进去的。然而，现在你看到的是所有的这些改变都在单一的一个差异中。</p>

<p>Git所做的只是把<code>feature1</code>中所有的commit的所有差异汇聚到一个单一的commit中。这个新的commit干了一些我们之前没有讨论过的事。从上图可以看到它拥有2个祖先，也就拥有着从<code>Commit 4</code>和<code>Commit 6</code>过来的两条线。为什么呢？commit可以保存多个先前commit的索引。我现在才来讲这个话题是因为我不想太早地引起混淆。</p>

<p>当一个commit被创建的时候，它所引用的之前commit数量可以是一个，多个，甚至没有。通常只有仓库中第一个commit才会没有先前commit，而merge commit一般都拥有超过一个的先前commit。</p>

<p>如果你还记得<a href="http://www.fusijie.com/blog/2014/10/08/what-is-a-commit-hash/">第一部分</a>的话，分支，其实实际上只是一个指向一个指定commit的指针而已。</p>

<p><img src="http://i.imgur.com/S0av3NM.png" alt="" /></p>

<p>你可能会注意到<code>feature1</code>仍然指向了<code>Commit 6</code>，而<code>master</code>分支指向了新的merge commit，很简单，因为我们是将<code>feature1</code> 合并到<code>master</code>。如果我们将分支切换到<code>feature1</code>，然后再把<code>master</code>合并进来，那么Git所做的就是一个<em>fast-forward</em> marge（快进合并），这会把<code>feature1</code>的指针指向最新的commit。</p>

<p><img src="http://i.imgur.com/Ggvb3UK.png" alt="" /></p>

<p>如果我们完全删除了<code>feature1</code>分支，你可能会以为粉色的线消失，但是你错了。</p>

<p><img src="http://i.imgur.com/rcSSPFa.png" alt="" /></p>

<p>记住，Source Tree和其他的Git可视工具是通过遍历你的commit，用索引的commit hash连接各个commit来生成图形的。分支只是一个指向指定commit的指针。当你从一个远程仓库拉取更新（pull）时，Git所做的是：</p>

<ul>
<li>1.下载所有你本地机器上没有的commit</li>
<li>2.合并丢失的commit到你的本地仓库，或是通过一个merge commit，或是通过一个<em>fast-forward</em> merge，前提是你在最后一次拉取更新后没有做任何的修改。</li>
<li>3.把你的本地分支指向最新的commit。</li>
</ul>


<p>如果你曾经混淆过<code>master</code>和<code>origin/master</code>指针，那现在你应该知道它们是是啥了。<code>origin/master</code>告诉你你的<code>origin</code>远程<code>master</code>分支指向哪。如果我给这个demo仓库添加了一个远程仓库叫<code>origin</code>，然后在本地仓库上做了一些commit，Git的历史可能会像这样：</p>

<p><img src="http://i.imgur.com/hSizNJB.png" alt="" /></p>

<p>你会看到<code>master</code>分支指向了最新的commit，而<code>origin/master</code>指向了前一个merge commit。Source Tree甚至提示我们说有一个commit可以推送（push）到远程仓库。如果我们推送上去，Git将会上传丢失的commit，然后更新你的远程分支指针，此时<code>origin/master</code>已经和你的本地<code>master</code>分支指向了相同的commit。</p>

<p><img src="http://i.imgur.com/pmyLiFb.png" alt="" /></p>

<p>希望你现在对Git的合并功能有了更好的理解。跳到<a href="">第三部分</a>让我们深究下rebase，看看它和merge有什么区别吧唧。</p>

<blockquote><p>英文地址:<a href="http://codetunnel.com/merge-vs-rebase-part-2-what-is-a-merge/">http://codetunnel.com/merge-vs-rebase-part-2-what-is-a-merge/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(译)第一部分：什么是commit hash?]]></title>
    <link href="http://www.fusijie.com/blog/2014/10/08/what-is-a-commit-hash/"/>
    <updated>2014-10-08T22:25:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2014/10/08/what-is-a-commit-hash</id>
    <content type="html"><![CDATA[<h4>内容提要</h4>

<ul>
<li>第一部分：commit hash是什么？</li>
<li>第二部分：<a href="http://www.fusijie.com/blog/2014/10/15/what-is-a-merge/">merge是什么？</a></li>
<li>第三部分：<a href="http://www.fusijie.com/blog/2014/11/18/what-is-a-rebase/">rebase是什么？</a></li>
</ul>


<p>最近一段时间我在学习如何使用<a href="http://git-scm.com/">Git</a>，碰到的一个难点：如何区别<a href="http://git-scm.com/docs/git-merge">merge</a>和<a href="http://git-scm.com/docs/git-rebase">rebase</a>？大部分人都能理解merge的概念，但是对于rebase就不是很清楚了。在这三篇博文中我将尽可能用最简单的方式来解释它们的异同。不过在此之前，我们需要先了解一下什么是commit hash。</p>

<!-- more -->


<p>如果你看过自己的commit历史，那么对于下面的内容肯定不会陌生：</p>

<p>```</p>

<pre><code>commit a9ca2c9f4e1e0061075aa47cbb97201a43b0f66f 
Author: Alex Ford 
Date: Mon Sep 8 6:49:17 2014

Initial commit.
</code></pre>

<p>```</p>

<p>你也许会认为这个由字母和数字组成的长长的字符串是一个单独commit的唯一的ID。虽然你是对的，但是你可能不知道它是一个<a href="http://en.wikipedia.org/wiki/SHA-1">SHA-1</a>生成的哈希码，用于表示一个git commit对象。如果不去深入理解git <a href="http://git-scm.com/book/en/Git-Internals-Git-Objects#Commit-Objects">commit object</a>，那顶多就只知道这是一个基于它所表示的信息直接生成的一个很大的加密字符串。改变一个commit hash的唯一方式就是改变commit的细节，本质上来说，其实是生成了一个全新的commit对象。</p>

<p>除了一些明显的信息，比如commit的作者，时间，存储的数据，commit通常还包含了在它之前的一个commit的hash，这正是你的commit历史产生的原因。每一个commit都知道紧跟它之前的commit hash。</p>

<p><img src="http://i.imgur.com/mljhFlh.png" alt="" /></p>

<p>上图可以看到我的<a href="https://www.atlassian.com/software/sourcetree/overview">SourceTree</a>窗口，打开了一个我创建的demo仓库。我做了3次commit。SourceTree相当智能，它可以读取仓库中的每一个commit，然后用图形的方式展现出commit历史。可以看到，<code>Commit 2</code>直接引用了<code>Commit 1</code>，而<code>Commit 1</code>直接引用了<code>Commit 0</code>。需要注意的是，在这里，我直接使用Commit字样作为commit描述，为的是尽可能简单地谈论这个话题。实际上，每一个commit信息都应该正确地描述它们所做的改变。</p>

<p>因为我的demo仓库master分支上只包含了这3个commit，所以SourceTree的图形从头到尾就是一条简单直线。好，现在我们就做点稍微复杂一点的事情，为了一个新的功能，我们需要创建一个独立的分支。</p>

<p><img src="http://i.imgur.com/S5o9qWL.png" alt="" /></p>

<p>从上图可以看到我创建了一个叫<code>feature1</code>的分支，但是图形仍然是一样的。这是因为在创建完新的分支后，我并没有进行任何新的commit。分支实际上只是指向一个特殊commit的指针。现在，<code>master</code>和<code>feature1</code>都指向了同一个commit。好了，我们往<code>feature1</code>分支添加一个新的commit</p>

<p><img src="http://i.imgur.com/qjIWl7F.png" alt="" /></p>

<p>可以看到，我们的<code>feature1</code>分支移动了它的指针来指向一个新的commit，<code>Commit 3</code>。你可以看到，我们的图形<em>仍然</em>是一条简单的直线。这是因为到目前为止，仅有4个commit，而每一个commit都是引用了紧跟它的前一个commit。如果我现在将<code>feature1</code>合并到<code>master</code>，只会发生一件事，就是<code>master</code>分支会直接跳到和<code>feature1</code>指向的相同commit，也就是<code>Commit 3</code>。这个叫做<em>fast-forward</em>合并（快进合并），因为它只是简单地将<code>master</code>分支的移动到指向最新的commit。</p>

<p>OK，当我们兴高采烈地在<code>feature1</code>上赶工，突然老板一个电话说一个新的Bug需要被马上解决，这是重中之重。这需要暂停<code>feature1</code>上的工作，然后马上在<code>master</code>分支上修复bug并提交。这个时候，我们不得不切换到<code>master</code>分支，然后进行一个commit。如果bug很大，可能得考虑是否要创建另一个分支，然后在这个分支上进行多个commit，现在假装bug很小，只要一个commit就能搞定。</p>

<p><img src="http://i.imgur.com/8MFZLBi.png" alt="" /></p>

<p>好了，现在看起来就有点不一样了，请注意上图的图形，<code>feature1</code>分支上的<code>Commit 3</code>在自己封闭的路径上了。原因很简单，<code>Commit 4</code>和<code>Commit 3</code>有相同的祖先。还记得commit是如何存储紧跟它之前的commit吗？当切换到<code>master</code>分支的时候，我们将会返回到<code>Commit 2</code>，因为<code>Commit 3</code>只由<code>feature1</code>分支指针引用。而<code>master</code>分支指针仍然指向<code>Commit 2</code>。因为我们的修复commit（<code>Commit 4</code>）将<code>Commit 2</code>视为它的前一个commit。</p>

<p>现在的图形告诉我们，<code>Commit 4</code>和<code>Commit 3</code>同时都引用了<code>Commit 2</code>作为他的前一个commit。在这种情况下，可以将<code>Commit 2</code>视为<code>Commit 3</code>和<code>Commit 4</code>共有的祖先。现在我们的修复已经被提交了，所以可以回到<code>feature1</code>分支继续工作了。</p>

<p><img src="http://i.imgur.com/kxDIgKl.png" alt="" /></p>

<p>现在我在<code>feature1</code>分支上创建了2个新的commit，<code>Commit 5</code>和<code>Commit 6</code>。新功能已经完成了，也是时候合并<code>feature1</code>分支到<code>master</code>分支中了。这时，我们可以选择merge <code>feature1</code>分支到<code>master</code>分支，也可以reabse <code>feature1</code>分支到<code>master</code>分支，让我们在<a href="http://www.fusijie.com/blog/2014/10/15/what-is-a-merge/">第二部分</a>中探究一下merge是什么？</p>

<blockquote><p>英文地址:<a href="http://codetunnel.com/merge-vs-rebase-part-1-what-is-a-commit-hash/">http://codetunnel.com/merge-vs-rebase-part-1-what-is-a-commit-hash/</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
