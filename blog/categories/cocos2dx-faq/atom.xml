<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cocos2dx-FAQ | Jacky's Blog]]></title>
  <link href="http://www.fusijie.com/blog/categories/cocos2dx-faq/atom.xml" rel="self"/>
  <link href="http://www.fusijie.com/"/>
  <updated>2014-09-01T18:26:07+08:00</updated>
  <id>http://www.fusijie.com/</id>
  <author>
    <name><![CDATA[FuSijie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cocos2dx-FAQ-1]]></title>
    <link href="http://www.fusijie.com/blog/2014/08/26/cocos2dx-faq-1/"/>
    <updated>2014-08-26T17:28:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2014/08/26/cocos2dx-faq-1</id>
    <content type="html"><![CDATA[<h3>1. <code>Q:</code>如何在安卓上给应用程序设置透明背景？</h3>

<p>(1)NativeActivity，以Cocos2d-x 3.0 rc0为例</p>

<p><a href="http://www.cocoachina.com/bbs/read.php?tid=196780">http://www.cocoachina.com/bbs/read.php?tid=196780</a></p>

<p>(2)JavaActivity，以Cocos2d-x 3.2 release为例</p>

<p><a href="http://www.cocoachina.com/bbs/read.php?tid=224544">http://www.cocoachina.com/bbs/read.php?tid=224544</a></p>

<!-- more -->




<br></br>


<h3>2. <code>Q:</code>SimpleAudioEngine在Windows平台上卡顿严重，无法调节音量？</h3>

<p>SimpleAudioEngine是分平台实现的，Windows平台上部分API是空实现（比如preloadBackgroundMusic等等）,所以在Windows平台上并不提供预加载，调节音量等功能（参见<a href="https://github.com/cocos2d/cocos2d-x/blob/v3/cocos/audio/win32/SimpleAudioEngine.cpp">cocos/audio/win32/SimpleAudioEngine.cpp</a>），移植到Android/iOS/Mac上就正常了。Windows上调节音量有网友提供了解决方案。</p>

<p>参考链接：<a href="http://www.cocoachina.com/bbs/read.php?tid=213345">http://www.cocoachina.com/bbs/read.php?tid=213345</a></p>

<br></br>


<h3>3. <code>Q:</code>Cocos2d-x 3.x无法重写Node::draw()方法？</h3>

<p>Cocos2d-x 从v3.0开始将Node::draw()方法标记为final（参见<a href="https://github.com/cocos2d/cocos2d-x/blob/v3/cocos/2d/CCNode.h">cocos2d/2d/CCNode.h</a>），引擎另外提供了</p>

<p>``` cpp draw函数</p>

<pre><code>virtual void draw(Renderer *renderer, const Mat4&amp; transform, uint32_t flags);
</code></pre>

<p>```</p>

<p>函数，可以通过重写这个函数来绘制你自己的节点，需注意的是如果更改了任何的GL状态，在使用完后必须还原。</p>

<p>参考链接：<a href="http://www.cocoachina.com/bbs/read.php?tid=200176">http://www.cocoachina.com/bbs/read.php?tid=200176</a></p>

<br></br>


<h3>4. <code>Q:</code>使用ClippingNode，为什么在Android/iOS裁剪显示错误，或者背景变为绿色？</h3>

<p>未开启OpenGL深度缓存，解决方法如下：</p>

<p><em>(1)iOS：在AppController.mm修改</em></p>

<p>``` objc iOS修改深度缓存</p>

<pre><code>EAGLView *__glView = [EAGLView viewWithFrame: [window bounds]
                                 pixelFormat: kEAGLColorFormatRGBA8
                                 depthFormat: GL_DEPTH24_STENCIL8_OES
                          preserveBackbuffer: NO
                                  sharegroup: nil
                               multiSampling: NO
                             numberOfSamples: 0];
</code></pre>

<p>```</p>

<p><em>(2)Android：在AppActivity.java修改</em></p>

<p>``` java Android修改深度缓存</p>

<pre><code>public class AppActivity extends Cocos2dxActivity {

public Cocos2dxGLSurfaceView onCreateView() {
    Cocos2dxGLSurfaceView glSurfaceView = new Cocos2dxGLSurfaceView(this);
    // TestCpp should create stencil buffer
       glSurfaceView.setEGLConfigChooser(5, 6, 5, 0, 16, 8);

    return glSurfaceView;
}
}
</code></pre>

<p>```</p>

<br></br>


<h3>5.<code>Q:</code>如何在Cocos2d-x实现C++调用Java？</h3>

<p>C++调用Java代码主要是通过JNI实现，这里以Cocos2d-x 3.2为例。</p>

<p>(1)C++部分：</p>

<p>在HelloWorld.cpp增加如下函数，用于调用java代码。</p>

<p>``` cpp C++代码</p>

<pre><code>#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)
#include &lt;jni.h&gt;
#include "platform/android/jni/JniHelper.h"
#include &lt;cocos2d.h&gt;
#endif

void HelloWorld::testJNI()
{
#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)
    JniMethodInfo minfo;

    bool isHave = JniHelper::getStaticMethodInfo(minfo,"org/cocos2dx/cpp/AppActivity","testjni", "()V");

    if (!isHave) {
        log("jni:testjni is null");
    }else{
        minfo.env-&gt;CallStaticVoidMethod(minfo.classID, minfo.methodID);
    }
#endif
}
</code></pre>

<p>```</p>

<p>(2)Java部分：</p>

<p>在org.cocos2dx.cpp.Activity中增加如下函数，供C++调用。</p>

<p>``` java Java代码</p>

<pre><code>public static void testjni() {  
    System.out.println("From Java"); 
}
</code></pre>

<p>```</p>

<p>更详细的使用说明，请参考：<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html">Java Native Interface Specification</a></p>

<br></br>


<h3>6.<code>Q:</code>如何在Cocos2d-x实现Java调用C++？</h3>

<p>Java调C++代码也是通过JNI实现，当然Android给我们提供了更方便的工具NDK。由于这里是以Cocos2d-x为例，所以不再去赘述NDK使用。同样以Cocos2d-x 3.2为例。</p>

<p>(1)C++部分：</p>

<p>在HelloWorld.cpp增加如下函数，供java调用。</p>

<p>``` cpp C++代码</p>

<pre><code>#include &lt;jni.h&gt;

#ifdef __cplusplus
extern "C" {
#endif
JNIEXPORT jstring JNICALL Java_org_cocos2dx_cpp_AppActivity_testjni
(JNIEnv *env, jclass)
{
    return env-&gt;NewStringUTF("From C++");
}
#ifdef __cplusplus
}
#endif
</code></pre>

<p>```</p>

<p>(2)Java部分：</p>

<p>在org.cocos2dx.cpp.Activity中增加如下函数，用于调用C++代码。</p>

<p>``` java java代码</p>

<pre><code>public class AppActivity extends Cocos2dxActivity {

@Override
protected void onCreate(Bundle savedInstanceState) {
    // TODO Auto-generated method stub
    super.onCreate(savedInstanceState);
    System.out.println(testjni());
}

public static native String testjni();
}
</code></pre>

<p>```</p>

<p>参考地址：<a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html">Java Programming Tutorial Java Native Interface</a></p>

<br></br>


<h3>7.<code>Q:</code>如何在Cocos2d-x实现截图功能？</h3>

<p><em>（1）Cocos2d-x 2.x</em></p>

<p>Cocos2d-x 2.x没有提供截图功能，但是可以用CCRenderTexture来实现这个功能</p>

<p>``` cpp SaveScreenShot</p>

<pre><code>void CTestLayer::SaveScreenShot()  
{  
    //获取屏幕尺寸  
    CCSize size = CCDirector::sharedDirector()-&gt;getWinSize();  
    //使用屏幕尺寸初始化一个空的渲染纹理对象  
    CCRenderTexture* texture = CCRenderTexture::create((int)size.width, (int)size.height);  
    //设置位置      
    texture-&gt;setPosition(ccp(size.width/2, size.height/2));  
    //开始获取      
    texture-&gt;begin();  
    //遍历场景节点对象，填充纹理到texure中  
    CCDirector::sharedDirector()-&gt;getRunningScene()-&gt;visit();  
    //结束获取  
    texture-&gt;end();  
    //保存为PNG图，Win32/Debug目录下  
    texture-&gt;saveToFile("screenshot.png", kCCImageFormatPNG);  
}  
</code></pre>

<p>```</p>

<p><em>（2）Cocos2d-x 3.x</em></p>

<p>在Cocos2d-x 3.2之前，引擎也没有提供截图功能，同样可以使用RenderTexture实现</p>

<p>``` cpp SaveScreenShot</p>

<pre><code>void Director::saveScreenshot(const std::string&amp; fileName,const std::function&lt;void(const std::string&amp;)&gt;&amp; callback)  
{  
    Image::Format format;  
    //进行后缀判断  
    if(std::string::npos != fileName.find_last_of(".")){  
    auto extension = fileName.substr(fileName.find_last_of("."),fileName.length());  
    if (!extension.compare(".png")) {  
        format = Image::Format::PNG;  
    } else if(!extension.compare(".jpg")) {  
        format = Image::Format::JPG;  
    } else{  
        log("cocos2d: the image can only be saved as JPG or PNG format");  
        return;  
    }  
} else {  
    log("cocos2d: the image can only be saved as JPG or PNG format");  
    return ;  
}  
//获取屏幕尺寸，初始化一个空的渲染纹理对象  
    auto renderTexture = RenderTexture::create(getWinSize().width, getWinSize().height, Texture2D::PixelFormat::RGBA8888);  
    //清空并开始获取  
    renderTexture-&gt;beginWithClear(0.0f, 0.0f, 0.0f, 0.0f);  
    //遍历场景节点对象，填充纹理到RenderTexture中  
    getRunningScene()-&gt;visit();  
    //结束获取  
    renderTexture-&gt;end();  
    //保存文件  
    renderTexture-&gt;saveToFile(fileName , format);  
    //使用schedule在下一帧中调用callback函数  
    auto fullPath = FileUtils::getInstance()-&gt;getWritablePath() + fileName;  
    auto scheduleCallback = [&amp;,fullPath,callback](float dt){  
        callback(fullPath);  
    };  
    auto _schedule = getRunningScene()-&gt;getScheduler();  
    _schedule-&gt;schedule(scheduleCallback, this, 0.0f,0,0.0f, false, "screenshot");  
}
</code></pre>

<p>```</p>

<p>从Cocos2d-x 3.2之后开始，引擎提供了captureScreen函数来实现截图功能</p>

<p>``` cpp captureScreen</p>

<pre><code>void Util::captureScreen(const std::function&lt;void(bool, const std::string&amp;)&gt;&amp; afterCaptured, const std::string&amp; filename);
</code></pre>

<p>```</p>

<br></br>


<h3>8.<code>Q:</code>如何在Cocos2d-x获取随机数？</h3>

<p>首先计算机是无法产生真正的随机数的，都是伪随机。获取随机数的方式和算法多种多样，这里只给出一种方法，基于最新的C++11。</p>

<p>``` cpp 随机数产生</p>

<pre><code>#include &lt;random&gt;

std::uniform_int_distribution&lt;unsigned&gt; u(1,1000);
std::default_random_engine e;
e.seed((unsigned)time(NULL));
int random_number = u(e);
</code></pre>

<p>```</p>

<p>这个例子产生了一个范围在1～1000的随机数（这里采用的标准分布是离散型均匀分布）。</p>

<p>参考：<a href="http://www.stroustrup.com/C++11FAQ.html#std-random">C++11:Random number generation</a></p>

<br></br>


<h3>9.<code>Q:</code>为什么直接点击Windows平台生成的exe可执行文件，提示程序已停止工作？</h3>

<p>这里以Cocos2d-x 3.2为例。</p>

<p>(1)如果直接在Visual Studio编译生成目标文件，那么目标文件会被生成到<code>项目/proj.win32/Debug.win32</code>目录下（debug模式）或者<code>项目/proj.win32/release.win32</code>目录下（release模式）。由于资源文件没有拷贝到目标文件目录的关系，此时点击xxx.exe，程序会停止工作。</p>

<p>解决方法是：手动将资源文件拷贝到xxx.exe同级目录下。</p>

<p>(2)如果采用的是命令行</p>

<pre><code>cocos run -p win32
</code></pre>

<p>那目标文件会被生成到<code>项目/bin/debug/win32</code>目录下，同时资源文件也会被拷贝到这个文件夹，此时直接点击xxx.exe就可以运行。<code>项目/proj.win32/Debug.win32</code>目录也会有xxx.exe，点击也会提示停止工作，解决方法同上。</p>

<br></br>



]]></content>
  </entry>
  
</feed>
