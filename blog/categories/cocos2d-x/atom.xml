<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cocos2d-x | Jacky's Blog]]></title>
  <link href="http://www.jacky.tk/blog/categories/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://www.jacky.tk/"/>
  <updated>2013-11-11T17:31:23+08:00</updated>
  <id>http://www.jacky.tk/</id>
  <author>
    <name><![CDATA[FuSijie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十七】cocos2d-x中文显示]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/25/play-cocos2dx-17/"/>
    <updated>2013-10-25T16:53:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/25/play-cocos2dx-17</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/13014883">http://blog.csdn.net/jackystudio</a></p>

<p>cocos2d-x的中文显示其实就是一个UTF-8编码在作怪而已，一种简单的方法就是把文本保存为UTF-8编码即可（注意不是UTF-8 + BOM），建议使用UE，Sublime Text或者EditPlus之类的本文编辑器。这里介绍另一种方法：通过读取xml文件显示中文，这种方法更利于软件的国际化，demo顺便实现了中英文切换。</p>

<!-- more -->


<h3>1.xml文件</h3>

<p>先写好一个xml文件（CHN_Strings.xml）。注意记得要以UTF-8编码保存。格式很简单，一个key对应一个string的键值对。如下：</p>

<pre><code>&lt;dict&gt;  
    &lt;key&gt;language&lt;/key&gt;  
    &lt;string&gt;English&lt;/string&gt;  
    &lt;key&gt;username&lt;/key&gt;  
    &lt;string&gt;偶尔e网事&lt;/string&gt;  
    &lt;key&gt;website&lt;/key&gt;  
    &lt;string&gt;CSDN博客：http://blog.csdn.net/jackystudio&lt;/string&gt;  
&lt;/dict&gt;  
</code></pre>

<h3>2.通过CCDictionary读取xml</h3>

<p>CCDictionary是利用哈希表算法来进行CCObject管理的一个类。这里不再对它的API及内部实现进行说明了。</p>

<p><strong>2.1.创建词典类实例</strong>
[cpp] view plaincopy
CCDictionary *chnStrings = CCDictionary::createWithContentsOfFile(&ldquo;CHN_Strings.xml&rdquo;);</p>

<p><strong>2.2.通过键（key）获取值（value）</strong></p>

<pre><code>const char *username = ((CCString*)chnStrings-&gt;objectForKey("username"))-&gt;m_sString.c_str();  
</code></pre>

<p><strong>2.3.使用value</strong></p>

<pre><code>CCLabelTTF* pLabel = CCLabelTTF::create(username, "Arial", 24);//这里创建一个文本  
pLabel-&gt;setPosition(ccp(origin.x + visibleSize.width/2,origin.y + visibleSize.height - pLabel-&gt;getContentSize().height));  
this-&gt;addChild(pLabel, 1);  
</code></pre>

<h3>3.效果</h3>

<p>这里我用了2个xml，一个是中文，一个是英文，设置了一个菜单，点击即可调用不同的xml进行中英文的切换，效果如下图。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_17/1.jpg" alt="" border="0" title="效果1" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_17/2.jpg" alt="" border="0" title="效果2" /><br></br></div>


<h3>4.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6442201">源码下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十六】滚动字幕和公告]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/24/play-cocos2dx-16/"/>
    <updated>2013-10-24T16:38:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/24/play-cocos2dx-16</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/12991977">http://blog.csdn.net/jackystudio</a></p>

<p>滚动字幕和公告是游戏中经常使用到的元素，本文大致写一下实现方法，至于例子中具体的坐标值，请不要纠结。。。这和美工关系还是蛮大的。我PS技术太搓了。。。</p>

<h3>1.原理</h3>

<p>其实它们的实现都是简单的通过调用update来更新位置达到的移动效果，和背景滚动有点类似，一旦滚动结束就重置为起点，开始新的滚动。只是为了达到在某个区域内滚动而不至于超出这个区域，有时候会用一些前景图来做遮盖，所以这个时候其实字幕或者公告是有在后面滚动的，但是被遮住了，因此看起来就像是只在某个区域内滚动。以垂直字幕滚动为例说明，如下图。</p>

<!-- more -->




<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_16/1.jpg" alt="" border="0" title="原理" /><br></br></div>


<h3>2.实现</h3>

<p>不要纠结以下各精灵的坐标位置：）</p>

<pre><code>bool CTestLayer::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCLayer::init());  

        CCSize visibleSize=CCDirector::sharedDirector()-&gt;getVisibleSize();  
        CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;addSpriteFramesWithFile("ui_serverlist.plist");  

        //垂直滚动字幕  
        CCSprite* listbase=CCSprite::createWithSpriteFrame(CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;spriteFrameByName("login_listbase.png"));//bottom底图  
        listbase-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2+10));  
        this-&gt;addChild(listbase);  
        text1=CCLabelTTF::create("1.Hi! Welcome to JackyStudio,\nMy Blog is\nblog.csdn.net/jackystudio!\n2.Hi! Welcome to JackyStudio,\nMy Blog is\nblog.csdn.net/jackystudio!\n3.Hi! Welcome to JackyStudio,\nMy Blog is\nblog.csdn.net/jackystudio!\n4.Hi! Welcome to JackyStudio,\nMy Blog is\nblog.csdn.net/jackystudio!","Arial",12);//middle文本  
        text1-&gt;setHorizontalAlignment(kCCTextAlignmentLeft);//左对齐  
        text1-&gt;setAnchorPoint(ccp(0.5,1));  
        text1-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2-55));  
        this-&gt;addChild(text1);  
        CCSprite* fg=CCSprite::create("fg.png");//top前景  
        fg-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2));  
        this-&gt;addChild(fg);  

        //水平滚动公告  
        CCSprite* textbase=CCSprite::createWithSpriteFrame(CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;spriteFrameByName("login_textbase.png"));  
        textbase-&gt;setPosition(ccp(visibleSize.width/2,50));  
        textbase-&gt;setScaleX(2.5f);  
        this-&gt;addChild(textbase);  
        text2=CCLabelTTF::create("Hi! Welcome to JackyStudio,My Blog is blog.csdn.net/jackystudio!","Arial",12);  
        text2-&gt;setPosition(ccp(visibleSize.width+text2-&gt;getContentSize().width/2,50));  
        text2-&gt;setColor(ccc3(255,0,0));//红色字体  
        this-&gt;addChild(text2);  

        this-&gt;scheduleUpdate();//执行更新  

        bRet=true;  
    } while (0);  
    return bRet;  
}  

void CTestLayer::update(float delta)  
{  
    CCSize visibleSize=CCDirector::sharedDirector()-&gt;getVisibleSize();  

    int newY=text1-&gt;getPositionY()+1;  
    if (newY==500)//如果滚动到这个位置，重置  
    {  
        newY=visibleSize.height/2-55;  
    }  
    text1-&gt;setPositionY(newY);  

    int newX=text2-&gt;getPositionX()-1;  
    if (newX&lt;=-text2-&gt;getContentSize().width/2)//如果滚动到这个位置，重置  
    {  
        newX=visibleSize.width+text2-&gt;getContentSize().width/2;  
    }  
    text2-&gt;setPositionX(newX);  
}  
</code></pre>

<h3>3.效果</h3>

<p>这个效果有点小bug，就是文字覆盖到边框上了，这是因为没有把边框做在top层上导致的，实际使用注意这个问题即可。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_16/2.jpg" alt="" border="0" title="字幕滚动和公告" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_16/3.jpg" alt="" border="0" title="字幕滚动和公告" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_16/4.jpg" alt="" border="0" title="字幕滚动和公告" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_16/5.jpg" alt="" border="0" title="字幕滚动和公告" /><br></br></div>


<h3>4.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6434549">源码下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十五】关卡选择的设计]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/23/play-cocos2dx-15/"/>
    <updated>2013-10-23T16:26:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/23/play-cocos2dx-15</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/12966993">http://blog.csdn.net/jackystudio</a></p>

<p>这节介绍一下游戏中帮助界面和关卡选择的设计，其实都是一样的，关键在于美工。这里采用自定义TableView层来实现。</p>

<h3>1.导入头文件和设定空间</h3>

<p>因为TableView相关的类是在扩展包里面，所以必须先声明</p>

<pre><code>#include "cocos-ext.h"  
USING_NS_CC_EXT;  
</code></pre>

<!-- more -->


<h3>2.继承的实现</h3>

<p>自定义TableView继承于CCLayer，因此可以捕获触摸，同时继承于扩展包的CCTableViewDataSource和CCTableViewDelegate。前者是TableView的数据源，包含了一系列和TableView数据单元相关的操作，后者则是继承于CCScrollViewDelegate抽象类，声明了一些和滚动，放大，触摸回调之类的接口，然后在内部包含了一个CCTableView，这用起来有点像Android的Adapter。当然分别继承几个类使用也是一样的。</p>

<p>先看一下要实现的接口吧。</p>

<pre><code>class TableViewTestLayer : public cocos2d::CCLayer, public cocos2d::extension::CCTableViewDataSource, public cocos2d::extension::CCTableViewDelegate  
{  
    public:  
    virtual bool init();    

    CREATE_FUNC(TableViewTestLayer);  

    virtual void scrollViewDidScroll(cocos2d::extension::CCScrollView* view){}//滚动时调用，空实现，因为继承了抽象类所以必须重写  
    virtual void scrollViewDidZoom(cocos2d::extension::CCScrollView* view){}//缩放时调用，空实现，同上  
    virtual void tableCellTouched(cocos2d::extension::CCTableView* table, cocos2d::extension::CCTableViewCell* cell);//触摸单元时回调  
    virtual cocos2d::CCSize tableCellSizeForIndex(cocos2d::extension::CCTableView *table, unsigned int idx);//设定单元所占大小  
    virtual cocos2d::extension::CCTableViewCell* tableCellAtIndex(cocos2d::extension::CCTableView *table, unsigned int idx);//设定单元内容  
    virtual unsigned int numberOfCellsInTableView(cocos2d::extension::CCTableView *table);//返回单元数  
};  
</code></pre>

<p>当然还有一些其他功能，如高亮，循环，看情况重载。</p>

<h3>3.自定义TabView层各模块的实现</h3>

<p><strong>3.1.初始化函数init</strong></p>

<pre><code>CCSize winSize = CCDirector::sharedDirector()-&gt;getWinSize();  
CCTableView* tableView = CCTableView::create(this, winSize);//创建一个CCTableView  
tableView-&gt;setDirection(kCCScrollViewDirectionHorizontal);//设置方向  
tableView-&gt;setPosition(ccp(0,winSize.height/2-50));  
tableView-&gt;setDelegate(this);//这句话很重要，把taleView和当前类绑到一起，所以后面的调用主体都是tableView  
this-&gt;addChild(tableView);  
tableView-&gt;reloadData();  
</code></pre>

<p><strong>3.2.触摸回调tableCellTouched</strong></p>

<pre><code>void TableViewTestLayer::tableCellTouched(CCTableView* table, CCTableViewCell* cell)  
{  
    CCLOG("cell touched at index: %i", cell-&gt;getIdx());//cell为当前选择单元  
}  
</code></pre>

<p><strong>3.3.单元大小tableCellSizeForIndex</strong></p>

<pre><code>CCSize TableViewTestLayer::tableCellSizeForIndex(CCTableView *table, unsigned int idx)  
{  
    //if (idx == 2) {  
    //    return CCSizeMake(100, 100);//第2个大小为100，100  
    //}  
    return CCSizeMake(120, 120);其余为120，120  
}  
</code></pre>

<p><strong>3.4.设置数据源tableCellAtIndex</strong></p>

<pre><code>CCTableViewCell* TableViewTestLayer::tableCellAtIndex(CCTableView *table, unsigned int idx)  
{  
    CCString *string = CCString::createWithFormat("%d", idx);  
    CCTableViewCell *cell = table-&gt;dequeueCell();  
    if (!cell) {  
        cell = new CCTableViewCell();//创建单元，如果要自定义单元效果，需继承CCTableViewCell，并重载draw函数  
        cell-&gt;autorelease();  
        CCSprite *sprite = CCSprite::create("HelloWorld.png");  
        sprite-&gt;setScale(0.2f);  
        sprite-&gt;setPosition(ccp(60, 60));  
        sprite-&gt;setTag(123);  
        cell-&gt;addChild(sprite);//添加到cell  
        CCLabelTTF *label = CCLabelTTF::create(string-&gt;getCString(), "Helvetica", 20.0);  
        label-&gt;setPosition(ccp(60,10));  
        label-&gt;setTag(456);  
        cell-&gt;addChild(label);//添加到cell  
    }  
    else  
    {  
        CCLabelTTF *label = (CCLabelTTF*)cell-&gt;getChildByTag(456);  
        label-&gt;setString(string-&gt;getCString());  
    }  
    return cell;  
}  
</code></pre>

<p><strong>3.5.单元数numberOfCellsInTableView</strong></p>

<pre><code>unsigned int TableViewTestLayer::numberOfCellsInTableView(CCTableView *table)  
{  
    return 20;//直接返回设定单元数  
}  
</code></pre>

<h3>4.效果图</h3>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_15/1.jpg" alt="" border="0" title="关卡1" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_15/2.jpg" alt="" border="0" title="关卡2" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_15/3.jpg" alt="" border="0" title="关卡3" /><br></br></div>


<h3>5.源码下载地址</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6422401">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十四】菜单选项卡的实现]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/22/play-cocos2dx-14/"/>
    <updated>2013-10-22T10:34:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/22/play-cocos2dx-14</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/12940733">http://blog.csdn.net/jackystudio</a></p>

<p>有时候，我们希望实现一个选项卡功能，就是切换tab选项，场景中的内容会跟着改变，但是tab选项卡不动。这是用切换场景的方式没办法做到的。
这里我们就可以使用CCLayerMultiplex来实现这个功能。</p>

<h3>1.创建布景</h3>

<p>这里创建3个布景来做示范。分别是Laye1，Layer2和Layer3。代码就不贴了，布景内容可以直接使用HelloWorld的代码。</p>

<!-- more -->


<h3>2.创建主场景</h3>

<p>主场景的初始化函数如下：</p>

<pre><code>bool CCMainScene::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCScene::init());  

        _layer1=CCLayer1::create();//创建3个层的实例  
        _layer2=CCLayer2::create();  
        _layer3=CCLayer3::create();  

        _layerMuticomplex=CCLayerMultiplex::create(_layer1,_layer2,_layer3,NULL);//创建多层布景层  
        this-&gt;addChild(_layerMuticomplex);//添加到场景，默认显示第一个布景  

        CCSize visibleSize = CCDirector::sharedDirector()-&gt;getVisibleSize();  
        CCPoint origin = CCDirector::sharedDirector()-&gt;getVisibleOrigin();  

        CCMenuItemImage *pCloseItem1 = CCMenuItemImage::create(//创建3个tab菜单，用于切换布景  
            "w_b.png",  
            "w_b.png",  
            this,  
            menu_selector(CCMainScene::menuCallback));  

        CCMenuItemImage *pCloseItem2 = CCMenuItemImage::create(  
            "r_b.png",  
            "r_b.png",  
            this,  
            menu_selector(CCMainScene::menuCallback));  

        CCMenuItemImage *pCloseItem3 = CCMenuItemImage::create(  
            "g_b.png",  
            "g_b.png",  
            this,  
            menu_selector(CCMainScene::menuCallback));  

        // create menu, it's an autorelease object  
        pCloseItem1-&gt;setTag(0);//给tab按钮设置tag，方便回调函数中的获取  
        pCloseItem2-&gt;setTag(1);  
        pCloseItem3-&gt;setTag(2);  
        CCMenu* pMenu = CCMenu::create(pCloseItem1, pCloseItem2, pCloseItem3, NULL);//创建菜单  
        pMenu-&gt;alignItemsHorizontallyWithPadding(-1);//设置菜单项间隔  
        pMenu-&gt;setPosition(visibleSize.width/2,25);  
        this-&gt;addChild(pMenu, 1);//注意哦，菜单要在场景中添加而不是在布景中了！而且z轴要高于多层布景，保证可见。  
        bRet=true;  
    } while (0);  
    return bRet;  
}  
</code></pre>

<p>回调函数如下：</p>

<pre><code>void CCMainScene::menuCallback(CCObject* pSender)  
{  
    int item=((CCMenuItemImage*)pSender)-&gt;getTag();//获取选择项  
    if (item!=curLayerPos)  
    {  
        _layerMuticomplex-&gt;switchTo(item);//切换布景，如果使用switchToAndReleaseMe会释放掉当前布景  
        curLayerPos=item;  
    }  
}  
</code></pre>

<h3>3.效果</h3>

<p>为了让效果明显一点，我让3个布景稍微有点区别。当然菜单是可以做normal，pressed，disable三态的，这里略去。点击不同的选项卡就可以切换到不同的布景层。当然CCLayerMultiplex还可以嵌套使用。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_14/1.jpg" alt="" border="0" title="效果" /><br></br></div>


<h3>4.源码下载地址</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6421801">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十三】CCMenu的布局]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/21/play-cocos2dx-13/"/>
    <updated>2013-10-21T10:23:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/21/play-cocos2dx-13</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/12904705">http://blog.csdn.net/jackystudio</a></p>

<p>前两天写个游戏，发现CCMenu的布局还是比较有意思的，这里总结一下，以便后用。</p>

<h3>1.概况</h3>

<p>CCMenu是cocos2d-x的菜单类，但它本身并不具备菜单具体属性，而是作为一个父节点，将一些具体类型的菜单添加进去来达到菜单目的的。我们正常会这么使用它：先创建子菜单项CCMenuItem，然后将子菜单项CCMenuItem加入菜单CCMenu，最后把CCMenu加入当前层CCLayer。</p>

<p>如果直接在层中添加CCMenuItem会怎样？其实显示也是会正常，但是无法响应回调，因为CCMenu是继承至CCLayer，也就继承了触摸的相关事件，而CCMenuItem只是从CCNode继承而来，并不响应触摸，因此无法调用回调函数。</p>

<!-- more -->


<h3>2.菜单CCMenu</h3>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_13/1.jpg" alt="" border="0" title="CCMenu" /><br></br></div>


<h3>3.子菜单项CCMenuItem</h3>

<p>子菜单项可以是用精灵，图片，标签文本，或者开关都可以，这里不具体解释。请看：</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_13/2.jpg" alt="" border="0" title="CCMenuItem" /><br></br></div>


<h3>4.锚点</h3>

<p>CCMenu继承于CCLayer，所以它具有忽略锚点的属性。而CCMenuItem的锚点是正常的(0.5,0.5)。</p>

<p>（1）看一下自带的HelloCpp这个工程，在添加退出按钮的时候，是不是有这么一句：</p>

<pre><code>pMenu-&gt;setPosition(CCPointZero);
</code></pre>

<p>这句话的作用就是把Menu放在原点的位置，假设Menu有大小，那就是下图1。</p>

<p>（2）现在再做点改变，把MenuItem指定的位置去掉，也就是让它默认在(0,0)位置上。</p>

<pre><code>//pCloseItem-&gt;setPosition(ccp(origin.x + visibleSize.width - pCloseItem-&gt;getContentSize().width/2 ,origin.y + pCloseItem-&gt;getContentSize().height/2));  
</code></pre>

<p>那么再看一下效果，如图2，抽象出来就是图3，因为CCMenuItem的锚点是(0.5,0.5)。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_13/3.jpg" alt="" border="0" title="" /><br></br></div>


<p>（3）所以现在可以理解HelloCpp中为什么定义的是CCMenuItem的位置，而不是定义CCMenu的位置了吧。CCMenu包含了多个子菜单项，每个子菜单的位置都不一样，如果定义了CCMenu的位置，那它作为父节点会影响到所有的子菜单的位置，因此我们一般把它设置在原点处，然后通过设置子菜单的位置（也就是相对父节点的偏移量）来定位整个菜单。</p>

<h3>5.多子菜单的排列</h3>

<p><em>（1）横向排列，纵向排列，可以指定间隔</em></p>

<pre><code>CCMenuItemImage *pCloseItem1 = CCMenuItemImage::create(  
    "CloseNormal.png",  
    "CloseSelected.png",  
    this,  
    menu_selector(HelloWorld::menuCloseCallback));  
CCMenuItemImage *pCloseItem2 = CCMenuItemImage::create(  
    "CloseNormal.png",  
    "CloseSelected.png",  
    this,  
    menu_selector(HelloWorld::menuCloseCallback));  

CCMenu* pMenu = CCMenu::create(pCloseItem1,pCloseItem2,NULL);  
pMenu-&gt;alignItemsHorizontally();//默认间隔是kDefaultPadding=5  
//pMenu-&gt;alignItemsHorizontallyWithPadding(20);//指定间隔  
//pMenu-&gt;alignItemsVertically();//默认间隔也是kDefaultPadding=5  
//pMenu-&gt;alignItemsVerticallyWithPadding(20);//指定间隔  
this-&gt;addChild(pMenu, 1);  
</code></pre>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_13/4.jpg" alt="" border="0" title="" /><br></br></div>


<p><em>（2）按行排列，按列排列，不能指定间隔，只能自己实现。希望下一版本有这个功能。</em></p>

<pre><code>CCMenuItemImage *pCloseItem1 = CCMenuItemImage::create(  
    "CloseNormal.png",  
    "CloseSelected.png",  
    this,  
    menu_selector(HelloWorld::menuCloseCallback));  
...  
CCMenuItemImage *pCloseItem6 = CCMenuItemImage::create(  
    "CloseNormal.png",  
    "CloseSelected.png",  
    this,  
    menu_selector(HelloWorld::menuCloseCallback));  
CCMenu* pMenu = CCMenu::create(pCloseItem1,pCloseItem2,pCloseItem3,pCloseItem4,pCloseItem5,pCloseItem6,NULL);  
pMenu-&gt;alignItemsInRows(3,2,1,NULL);  
//pMenu-&gt;alignItemsInColumns(3,2,1,NULL);  
this-&gt;addChild(pMenu, 1);  
</code></pre>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_13/5.jpg" alt="" border="0" title="" /><br></br></div>

]]></content>
  </entry>
  
</feed>
