<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cocos2d-x | Jacky's Blog]]></title>
  <link href="http://www.fusijie.com/blog/categories/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://www.fusijie.com/"/>
  <updated>2013-12-09T08:44:20+08:00</updated>
  <id>http://www.fusijie.com/</id>
  <author>
    <name><![CDATA[FuSijie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十九】利用CCClipingNode做游戏遮罩]]></title>
    <link href="http://www.fusijie.com/blog/2013/12/06/play-cocos2dx-29/"/>
    <updated>2013-12-06T10:41:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/12/06/play-cocos2dx-29</id>
    <content type="html"><![CDATA[<p>新手引导是游戏中必备的（除了奇葩的MT用一段动画开始），也是玩家对游戏的第一印象，重要性不言而喻。一般采用的遮罩的形式来突出引导重点，同时屏蔽其他功能。这里简单的介绍一下游戏遮罩的实现，并给出一个示例。</p>

<h3>1.CCClipingNode</h3>

<p>CCClipingNode是一个可裁剪节点，简单理解：</p>

<p><em>（1）首先它是一个节点，继承于CCNode，所以它可以像普通节点一样放入CCLayer，CCScene，CCNode中。</em></p>

<p><em>（2）作为节点，它就可以用作容器，承载其他节点和精灵。我把它叫底板。</em></p>

<p><em>（3）如果想要对一个节点进行裁剪，那需要给出裁剪的部分，这个裁剪区域，我把它叫模版。</em></p>

<!-- more -->


<p>所以CCClipingNode裁剪节点在组成上=底板+模版，而在显示上=底板-模版。不知道这样解释会不会好理解一点。</p>

<div align="center"><img src="http://www.fusijie.com/images/Blog/Play_cocos2dx_29/1.jpg" alt="" border="0" title="CCClipingNode" /><br></br></div>


<h3>2.API</h3>

<p>CCClipingNode的使用还是比较简单的，至于显示底板还是模版，alpha值的设定，这些也不好说清楚，自己多试几次就知道是什么意思该怎么用了。</p>

<pre><code>//不带模版地创建一个裁剪节点  
static CCClippingNode* create();  

//使用一个节点作为模版创建裁剪节点  
static CCClippingNode* create(CCNode *pStencil);  

//不带模版地初始化一个裁剪节点  
virtual bool init();  

//使用一个节点作为模版初始化裁剪节点  
virtual bool init(CCNode *pStencil);  

//设置/获取模版，注意模版需要retain！  
CCNode* getStencil() const;  
void setStencil(CCNode *pStencil);  

//设置alpha值（0~1），这个很重要，裁剪是按像素抠图的，所以只有大于这个alpha值的模版像素才会被画出来  
//默认是1，也就是完全裁剪。  
GLfloat getAlphaThreshold() const;  
void setAlphaThreshold(GLfloat fAlphaThreshold);  

//默认是false，用于设置显示底板还是模版  
bool isInverted() const;  
void setInverted(bool bInverted);  
</code></pre>

<h3>3.示例</h3>

<p>在init中实现：</p>

<pre><code>CCSize visibleSize=CCDirector::sharedDirector()-&gt;getVisibleSize();  

CCSprite* background = CCSprite::create("HelloWorld.png");//创建背景  
background-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2));  
this-&gt;addChild(background,kTagBackground);  

clip=CCClippingNode::create();//创建裁剪节点，成员变量  
clip-&gt;setInverted(true);//设置底板可见  
clip-&gt;setAlphaThreshold(0.0f);//设置alpha为0  
this-&gt;addChild(clip,kTagClipNode);//添加裁剪节点  

CCLayerColor* back=CCLayerColor::create(ccc4(0,0,0,200));  
clip-&gt;addChild(back);//为裁剪节点添加一个黑色带透明（看起了是灰色）的底板  

//模版如果要在其他地方使用要记得retain！  

//第一种：以下模型是drawnode遮罩  
//CCDrawNode* front=CCDrawNode::create();  
//ccColor4F yellow = {1, 1, 0, 1};  
//CCPoint rect[4]={ccp(-30,30),ccp(30,30),ccp(30,-30),ccp(-30,-30)};  
//front-&gt;drawPolygon(rect, 4, yellow, 0, yellow);  
//front-&gt;setPosition(ccp(visibleSize.width/2, visibleSize.height/2));  
//clip-&gt;setStencil(front);  

//第二种：以下模型是带图像遮罩  
CCNode* nodef=CCNode::create();//创建模版  
CCSprite* close=CCSprite::create("CloseSelected.png");//这里使用的是close的那个图标，所以注意观察效果图2  
nodef-&gt;addChild(close);//在模版上添加精灵  
nodef-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2));  
clip-&gt;setStencil(nodef);//设置模版  

tip = CCSprite::create("tip.png");//一些引导提示  
tip-&gt;setScale(0.5f);  
tip-&gt;setRotation(60);  
tip-&gt;setPosition(ccp(visibleSize.width/2-70,visibleSize.height/2+50));  
this-&gt;addChild(tip,kTagTip);  

tip-&gt;runAction(CCRepeatForever::create(CCSequence::create(CCScaleBy::create(0.25f,0.95f),CCScaleTo::create(0.25f,0.5),NULL)));  

this-&gt;setTouchEnabled(true);//触摸有效，落点正确时移除裁剪节点和提示，相关处理请看源码  
</code></pre>

<h3>4.效果</h3>

<p>两种效果：</p>

<div align="center"><img src="http://img.blog.csdn.net/20131206102326578" alt="" border="0" title="1" /><br></br></div>




<div align="center"><img src="http://img.blog.csdn.net/20131206102337937" alt="" border="0" title="2" /><br></br></div>


<h3>5.源码</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6667189">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十八】cocos2d-x的消息和数据传递]]></title>
    <link href="http://www.fusijie.com/blog/2013/12/03/play-cocos2dx-28/"/>
    <updated>2013-12-03T09:57:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/12/03/play-cocos2dx-28</id>
    <content type="html"><![CDATA[<p>如何在层间或者场景间进行消息传递，大概是每个初学者都要面对的问题吧。这里介绍cocos2d-x的一种消息/数据传递方式，内置的观察者模式，也称消息通知中心，CCNotificationCenter。</p>

<h3>1.CCNotificationCenter</h3>

<p>CCNotificationCenter是cocos2d-x提供的一个消息中心，类似于观察者模式，是一个单例类，用于辅助控制消息传递。大概工作原理如下图。</p>

<!-- more -->




<div align="center"><img src="http://www.fusijie.com/images/Blog/Play_cocos2dx_28/1.jpg" alt="" border="0" title="CCNotificationCenter" /><br></br></div>


<p>这里以A，B通讯为例，A，B可以是层间或者场景间。假如A要向B发送带数据的消息。那么</p>

<p><em>（1）B向小心中心注册一个bMsg的消息，告知消息中心，如果消息中心接收到bMsg，必须通知B，以便B采取相应的措施。</em></p>

<p><em>（2）A向消息中心发送bMsg消息。</em></p>

<p><em>（3）消息中心接收到bMsg，查询有谁在它这里注册了这个消息，发现是B，就通知B有人发送了bMsg。</em></p>

<p><em>（4）当然这个消息带有A要传递的数据，而B也不知道到底是谁给它发了bMsg这条消息，除非在传递的数据中指出。</em></p>

<h3>2.相关API</h3>

<pre><code>//获得消息通知中心的一个单例对象  
static CCNotificationCenter *sharedNotificationCenter(void);  

//销毁通知中心的单例对象  
static void purgeNotificationCenter(void);  

//添加观察者  
void addObserver(CCObject *target,   
                SEL_CallFuncO selector,  
                const char *name,  
                CCObject *obj);  

//移除观察者  
void removeObserver(CCObject *target,const char *name);  

//移除所有观察者  
int removeAllObservers(CCObject *target);  

//发送消息  
void postNotification(const char *name);  

//发送带数据的消息  
void postNotification(const char *name, CCObject *object);  
</code></pre>

<p>观察者的意思即是等待获取消息的对象，比如上图的B。</p>

<h3>3.原理</h3>

<p>CCNotificationCenter的实现比较简单，它的内部维护了一个CCArray数组，数组的元素是CCNotificationObserver类型的对象，CCNotificationObserver封装了回调的执行者，回调函数，消息名称以及传递的数据。每次注册，也就是添加观察者，其实就是把这个CCNotificationObserver对象加入通知中心的CCArray数组，而每次的消息发送就是将消息传递给通知中心，由通知中心遍历这个数组，找到一致的消息，调用这些回调函数。其实这样看起来，就像是A在调用B的函数。具体的就自己看下源码吧。</p>

<h3>4.示例</h3>

<p>这里做了一个场景，包含了2个层，目的是层A向层B发送带数据的消息，层B收到后打印出这条数据。</p>

<pre><code>//ALayer  
bool ALayer::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCLayer::init());  
        CCSize visibleSize = CCDirector::sharedDirector()-&gt;getVisibleSize();  
        CCMenuItemImage *pCloseItem = CCMenuItemImage::create(  
            "CloseNormal.png",  
            "CloseSelected.png",  
            this,  
            menu_selector(ALayer::PostMessage));//按钮用于点击发送消息  

        pCloseItem-&gt;setAnchorPoint(ccp(0.5,0.5));  
        pCloseItem-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2));  
        CCMenu* pMenu = CCMenu::create(pCloseItem, NULL);  
        pMenu-&gt;setPosition(CCPointZero);  
        this-&gt;addChild(pMenu, 1);  

        bRet=true;  
    } while (0);  
    return bRet;  
}  

void ALayer::PostMessage(CCObject* pSender)  
{  
    CCString* str=CCString::create("Hello BLayer!");  
    CCNotificationCenter::sharedNotificationCenter()-&gt;postNotification("BMessage",str);//发送带str的消息BMessage  
}  

//BLayer  
bool BLayer::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCLayer::init());  

        CCNotificationCenter::sharedNotificationCenter()-&gt;addObserver(this,callfuncO_selector(BLayer::getMessage),"BMessage",NULL);//注册BMessage，如果接收到了，执行getMessage  

        bRet=true;  
    } while (0);  
    return bRet;  
}  

void BLayer::getMessage(CCObject* obj)  
{  
    CCString* str=static_cast&lt;CCString*&gt;(obj);//打印出传递的数据  
    CCLog(str-&gt;getCString());  
}  

BLayer::~BLayer(void)  
{  
    CCNotificationCenter::sharedNotificationCenter()-&gt;purgeNotificationCenter();//释放通知中心单例对象  
}  
</code></pre>

<h3>5.注意</h3>

<p>使用CCNotificationCenter需要注意以下几点：</p>

<p><em>（1）一个对象可以注册多个消息，一个消息也可以由多个消息注册。</em></p>

<p><em>（2）传递参数，A可以向B传递参数，而B在注册的时候也可以带一个参数，如果这两个数据不是指向同一对象的话，消息不会传递。也就是说要么A传递NULL对象，要么B注册时带NULL对象，要么都不是NULL但必须是同一对象，消息传递才会成功。以下是发送消息执行的判断：</em></p>

<pre><code>if (!strcmp(name,observer-&gt;getName()) &amp;&amp; (observer-&gt;getObject() == object || observer-&gt;getObject() == NULL || object == NULL))  
</code></pre>

<p><em>（3）局部变量的传递，注意到上例，传递的是CCString的一个局部变量（但还是要autorelease），从CCNotificationCenter的实现上来看，这是没有问题的，因为数据是在postNotification被调用的，也就是整个函数体并没结束，数据不会被销毁。</em></p>

<h3>6.效果图</h3>

<div align="center"><img src="http://img.blog.csdn.net/20131204150850171" alt="" border="0" title="效果" /><br></br></div>


<h3>7.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6647453">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十七】CCSequence不能执行CCRepeatForever]]></title>
    <link href="http://www.fusijie.com/blog/2013/11/28/play-cocos2dx-27/"/>
    <updated>2013-11-28T09:25:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/11/28/play-cocos2dx-27</id>
    <content type="html"><![CDATA[<p>之前在遇到这么一个问题，在CCSequence中加入CCRepeatForever，发现其他动作执行没问题，就是CCRepeatForever无法执行。代码并没有问题，很奇怪。</p>

<h3>1.示例</h3>

<pre><code>CCBlink* blink=CCBlink::create(0.5f,10);//创建闪烁动画，duration=0.5s  
CCAnimation* animation=CCAnimation::create();  
animation-&gt;addSpriteFrameWithFileName("CloseNormal.png");  
animation-&gt;addSpriteFrameWithFileName("CloseSelected.png");  
animation-&gt;setDelayPerUnit(1.0f);//帧间间隔1s  
CCAnimate* animate=CCAnimate::create(animation);//创建帧动画  
CCRepeatForever* repeat=CCRepeatForever::create(animate);  
CCSequence* sequence=CCSequence::create(blink,repeat,NULL);//创建连续动画  
CCSprite* close=CCSprite::create("CloseNormal.png");  
close-&gt;setPosition(ccp(240,160));  
this-&gt;addChild(close);  
close-&gt;runAction(sequence);//执行连续动画  
</code></pre>

<p>结果精灵闪烁10次以后，帧动画不执行了。</p>

<!-- more -->


<h3>2.原因</h3>

<p>先了解一下CCSequence的创建和执行原理。</p>

<p><strong>2.1.CCSequence的创建</strong></p>

<p>创建CCSequence调用</p>

<pre><code>//创建CCSequence  
CCSequence* CCSequence::create(CCFiniteTimeAction *pAction1, ...)  
</code></pre>

<p>内部调用了createWithVariableList，从实现可以看出这是一个递归调用。</p>

<pre><code>//获取动作列表，创建CCSequence  
CCSequence* CCSequence::createWithVariableList(CCFiniteTimeAction *pAction1, va_list args)  
{  
    CCFiniteTimeAction *pNow;//当前动作  
    CCFiniteTimeAction *pPrev = pAction1;//第一个动作  
    bool bOneAction = true;//只有一个动作的标志位  

    while (pAction1)  
    {  
        pNow = va_arg(args, CCFiniteTimeAction*);//获取当前动作  
        if (pNow)//如果存在  
        {  
            pPrev = createWithTwoActions(pPrev, pNow);//用前两个动作创建CCSequence并赋给第一个动作  
            bOneAction = false;//置false  
        }  
        else//如果不存在  
        {  
            // If only one action is added to CCSequence, make up a CCSequence by adding a simplest finite time action.  
            if (bOneAction)//如果只有一个动作  
            {  
                pPrev = createWithTwoActions(pPrev, ExtraAction::create());  
            }  
        break;//跳出循环  
        }  
    }  
    return ((CCSequence*)pPrev);//返回第一个动作  
}  
</code></pre>

<p>假如有3个动作要被串联，则先把第1个和第2个串联一个CCSequence，再把这个CCSequence和第3个动作串联成最终的CCSequence，然后返回。从CCSequence的成员变量可以看到：</p>

<pre><code>CCFiniteTimeAction *m_pActions[2];//表明只包含2个动作对象指针
</code></pre>

<p>使用递归多少会降低程序的运行效率，但是却可以换来代码的简洁性，同样的CCSpawn也是这么实现的。
在createWithTwoActions中，调用了initWithTwoActions函数，实现了把两个动作串成一个CCSequence，关键代码如下：</p>

<pre><code>float d = pActionOne-&gt;getDuration() + pActionTwo-&gt;getDuration();//获取两个动作的duration  
CCActionInterval::initWithDuration(d);//赋给新的CCSequence  

m_pActions[0] = pActionOne;//同时把两个动作赋给m_pActions指针数组  
pActionOne-&gt;retain();  

m_pActions[1] = pActionTwo;  
pActionTwo-&gt;retain();  
</code></pre>

<p><strong>2.2.duration</strong></p>

<p>从示例可以看出，闪烁动画blink的duration是0.5s，那CCRepeatForever呢？1s？当然不是，1s只是帧动画animate的帧间间隔，每个帧动画包含2帧，而CCRepeatForever的duration是0。因此，当示例中的闪烁动画blink和重复动画repeat串联成CCSequence sequence的时候，sequence的duration就变成0.5+0=0.5s，这很重要。</p>

<p><strong>2.3.m_split</strong></p>

<p>CCSequence中有这么一个成员变量</p>

<pre><code>float m_split;//记录了第一个动画时长占总时长的比例，也就是2个动画的时长分界  
</code></pre>

<p>当执行runAction的时候，CCSequence会调用</p>

<pre><code>void CCSequence::startWithTarget(CCNode *pTarget)  
{  
    CCActionInterval::startWithTarget(pTarget);  
    m_split = m_pActions[0]-&gt;getDuration() / m_fDuration;//获取第一个动画占总时长的比例  
    m_last = -1;  
}  
</code></pre>

<p>而这里由于blink占了0.5s，repeat占了0s，总时长0.5s，所以m_split是0.5/0.5=1。blink占满了整个CCSequence，所以CCSequence无法执行repeat。</p>

<p>这时候再来看CCSequence::update(float dt)函数的执行，就会恍然大悟了。</p>

<pre><code>int found = 0;//当前播放动作索引  
float new_t = 0.0f;//新播放进度  

if( t &lt; m_split ) {//播放进度&lt;分界进度  
    found = 0;//设置当前播放的是第一个动作  
    if( m_split != 0 )//如果第一个动作时长占比!=0  
        new_t = t / m_split;//计算出第一个动作新的播放进度  
    else  
        new_t = 1;//设置第一个已播放完毕  

} else {//播放进度&gt;=分界进度  
    found = 1;//设置当前播放的是第二个动作  
    if ( m_split == 1 )//如果第一个动作时长占比==1  
        new_t = 1;//设置第二个动作已完成  
    else  
        new_t = (t-m_split) / (1 - m_split );//计算出第二个动作新的播放进度  
}  
</code></pre>

<h3>3.注意</h3>

<p><em>（1）CCSpawn也会有这个问题，所以CCSpawn也无法执行加入其中的CCRepeatForever动作。</em></p>

<p><em>（2）CCRepeatForever的反转动作也是无效了，一个不会停止的动作从什么地方开始反转？当然你可以先把动作反转了再加入CCRepeatForever中，这是没问题的。</em></p>

<h3>4.解决方案</h3>

<p><em>（1）对于同时动作，不使用CCSpawn，采用分别执行</em></p>

<pre><code>close-&gt;runAction(blink);  
close-&gt;runAction(repeat);  
</code></pre>

<p><em>（2）对于连续动作，不直接往CCSequence中加入CCRepeatForever，而是把CCRepeatForever放入瞬时动作CCCallFunc中，再把CCCallFunc加入CCSequence中执行。</em></p>

<pre><code>close=CCSprite::create("CloseNormal.png");  
CCBlink* blink=CCBlink::create(0.5f,10);  
CCCallFunc* callFunc=CCCallFunc::create(this,callfunc_selector(TestScene::repeatFunc));//创建CCCallFunc对象  
CCSequence* sequence=CCSequence::create(blink,callFunc,NULL);//把CCCallFunc对象加入CCSequence中  
close-&gt;setPosition(ccp(240,160));  
this-&gt;addChild(close);  
close-&gt;runAction(sequence);  


void TestScene::repeatFunc()  
{  
    CCAnimation* animation=CCAnimation::create();  
    animation-&gt;addSpriteFrameWithFileName("CloseNormal.png");  
    animation-&gt;addSpriteFrameWithFileName("CloseSelected.png");  
    animation-&gt;setDelayPerUnit(1.0f);  
    CCAnimate* animate=CCAnimate::create(animation);  
    CCRepeatForever* repeat=CCRepeatForever::create(animate);  
    close-&gt;runAction(repeat);  
}  
</code></pre>

<p><em>（3）对于CCAnimation帧动画，可以设置循环属性，而不使用CCRepeatForever。</em></p>

<pre><code>animation-&gt;setLoops(-1);  
</code></pre>

<h3>5.总结</h3>

<p>虽然CCRepeatForever也同样继承于CCActionInterval，理论上是延时动作的子类，但是和一般的延时动作又有很大的不同，所以平时在使用的时候必须很小心，不能当成一般的CCActionInterval使用。而在cocos2d-x动作的分类上是不是应该把它从CCAction继承出来会比较好一点？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十六】数据结构CCDictionary]]></title>
    <link href="http://www.fusijie.com/blog/2013/11/26/play-cocos2dx-26/"/>
    <updated>2013-11-26T09:00:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/11/26/play-cocos2dx-26</id>
    <content type="html"><![CDATA[<p>CCDictionary在cocos2d-x中被大量的应用，比如CCTexureCache，CCSpriteFramCache等等。</p>

<h3>1.实现原理</h3>

<p><strong>1.1.uthash</strong></p>

<p>CCDictionary是使用uthash实现的，而过时的CCMutableDictionary则是使用STL实现，就效率而言CCDictionary至少提升了两倍，而且CCDictionary并没有使用C++模版，因此也很容易绑定到脚本。</p>

<p>uthash是一个C/C++的哈希表实现，它以宏定义的方式实现了哈希表，不仅加快了运行速度，而且与key类型无关。它的github在<a href="https://github.com/troydhanson/uthash">这里</a>。cocos2d-x的头文件在\cocos2d-x-2.2.0\cocos2dx\support\data_support\uthash.h。</p>

<!-- more -->


<p>如果想在C++中直接使用也很简单，userguide在<a href="http://troydhanson.github.io/uthash/userguide.html">这里</a>。可以很方便地进行增加，删除，查找，计数，迭代，排序等操作。</p>

<p><strong>1.2.键（key）</strong></p>

<p>uthash支持4种标准类型的键：整型，字符串，指针和结构体，不过到了CCDictionary就只支持整型和字符串型了。</p>

<pre><code>enum CCDictType  
{  
    kCCDictUnknown = 0,  
    kCCDictStr,  
    kCCDictInt  
};  
</code></pre>

<h3>2.CCDictElement</h3>

<p>在了解CCDictionary之前还要看一下CCDictElement，很明显，CCDictElement是CCDictionary的一个元素，包含了一个key-value。key支持整型和字符串，使用的时候要注意在同一个CCDictionary中key类型必须要一致，value可以不一致。</p>

<h3>3.API</h3>

<p><strong>3.1.创建</strong></p>

<pre><code>//创建一个CCDictionary  
static CCDictionary* create();  
//用一个已存在的CCDictionary来创建一个新的CCDictionary  
static CCDictionary* createWithDictionary(CCDictionary* srcDict);  
//用一个plist来创建CCDictionary  
static CCDictionary* createWithContentsOfFile(const char *pFileName);  
//返回一个非autorelease对象的CCDictionary，它讷讷感够确保在新线程中使用  
//但是你必须手动管理它的生命周期，当你不再需要它的时候，必须调用CC_SAFE_RELEASE  
static CCDictionary* createWithContentsOfFileThreadSafe(const char *pFileName); 
</code></pre>

<p><strong>3.2.查找</strong></p>

<pre><code>//返回指定字符串类型key的value，如果CCDictionary的key是整型，会出现断言  
CCObject* objectForKey(const std::string&amp; key);  
//返回指定整型key的value，如果CCDictionary的key是字符串型，会出现断言  
CCObject* objectForKey(intptr_t key);  
//返回指定字符串类型key的CCString，这里假定value是CCString型，如果不是或者未找到，则返回空串  
const CCString* valueForKey(const std::string&amp; key);  
//返回指定整型类型key的CCString，这里假定value是CCString型，如果不是或者未找到，则返回空串  
const CCString* valueForKey(intptr_t key);  
</code></pre>

<p><strong>3.3.增加</strong></p>

<pre><code>//插入一个key-value，如果是第一次调用，那么CCDictionary的key类型会被确定为字符串型，之后就不能插入整型key  
//如果已存在该key，则旧key-value会被释放和移除，被新的替代  
void setObject(CCObject* pObject, const std::string&amp; key);  
//插入一个key-value，如果是第一次调用，那么CCDictionary的key类型会被确定为整型，之后就不能插入字符串型key  
//如果已存在该key，则旧key-value会被释放和移除，被新的替代  
void setObject(CCObject* pObject, intptr_t key);  
</code></pre>

<p><strong>3.4.移除</strong></p>

<pre><code>//移除指定key  
void removeObjectForKey(const std::string&amp; key);  
void removeObjectForKey(intptr_t key);  
//移除一个CCArray中keys  
void removeObjectsForKeys(CCArray* pKeyArray);  
//通过元素来移除value  
void removeObjectForElememt(CCDictElement* pElement);  
//移除所有的key-value  
void removeAllObjects();
</code></pre>

<p><strong>3.5.其他</strong></p>

<pre><code>//返回一个随机元素，这个使用得注意，因为value可以不一样，所以返回类型每次都可能不同，在类型转换的时候要非常小心  
CCObject* randomObject();  
//返回一个包含所有key的CCArray  
CCArray* allKeys();  
//返回指定value的所有key，因为value是可以相同的，内部使用==比较两个value是否相同   
CCArray* allKeysForObject(CCObject* object);  
//返回元素个数  
unsigned int count();  
//把CCDictionary写到一个plist中，写入的value要求是字符串型  
bool writeToFile(const char *fullPath);  
</code></pre>

<h3>4.示例</h3>

<pre><code>// Create a dictionary, return an autorelease object.  
CCDictionary* pDict = CCDictionary::create();  

// Insert objects to dictionary  
CCString* pValue1 = CCString::create("100");  
CCString* pValue2 = CCString::create("120");  
CCInteger* pValue3 = CCInteger::create(200);  
pDict-&gt;setObject(pValue1, "key1");  
pDict-&gt;setObject(pValue2, "key2");  
pDict-&gt;setObject(pValue3, "key3");  

// Get the object for key  
CCString* pStr1 = (CCString*)pDict-&gt;objectForKey("key1");  
CCLog("{ key1: %s }", pStr1-&gt;getCString());  
CCInteger* pInteger = (CCInteger*)pDict-&gt;objectForKey("key3");  
CCLog("{ key3: %d }", pInteger-&gt;getValue());  
CCString* pStr3=static_cast&lt;CCString*&gt;(pDict-&gt;randomObject());//这里有问题了，因为value有不同类型，所以随机返回时类型处理要小心  
CCLog("{ random key: %s }",pStr3-&gt;getCString());  //如果返回的是整型pValue3，那么会出现断言  
if(pDict-&gt;writeToFile("pdic.plist"))  //整型的value无法写入，会提示This type cannot appear in property list  
    CCLog("Write to file success!");  
</code></pre>

<p>Resource/pdic.plist</p>

<div align="center"><img src="http://www.fusijie.com/images/Blog/Play_cocos2dx_26/1.jpg" alt="" border="0" title="pdic.plist" /><br></br></div>


<p></p>

<h3>5.CCDICT_FOREACH</h3>

<p><strong>5.1.概况</strong></p>

<p>宏定义，用于遍历CCDictionary的value。</p>

<pre><code>#define CCDICT_FOREACH(__dict__, __el__) \  
CCDictElement* pTmp##__dict__##__el__ = NULL; \  
if (__dict__) \  
HASH_ITER(hh, (__dict__)-&gt;m_pElements, __el__, pTmp##__dict__##__el__)  
</code></pre>

<p><strong>5.2.示例</strong></p>

<pre><code>CCDictElement* pElement;  
CCDICT_FOREACH(dict, pElement)  
{  
    const char*key = pElement-&gt;getStrKey();  
    // You certainly know the type of value, so we assume that it's a CCSprite.  
    CCSprite* pSprite = (CCSprite*)pElement-&gt;getObject();  
    // ......  
}  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十五】数据结构CCArray]]></title>
    <link href="http://www.fusijie.com/blog/2013/11/25/play-cocos2dx-25/"/>
    <updated>2013-11-25T13:53:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/11/25/play-cocos2dx-25</id>
    <content type="html"><![CDATA[<p>CCArray是从cocos2d中移植过来的，类似于Apple的NSMutableArray，但是比NSMutableArray更为的好用。要注意的是虽然CCArray和CCDictionary可以管理cocos2d-x中绝大多数的类，但是仍然无法替代STL库，STL库更为强有力。</p>

<h3>1.API</h3>

<p>先看一下CCArray可以帮我们做什么。</p>

<!-- more -->


<p><strong>1.1.创建</strong></p>

<pre><code>//创建array  
static CCArray* create();  
//使用一系列CCObject创建array  
static CCArray* create(CCObject* pObject, …);  
//使用一个CCObject创建array  
static CCArray* createWithObject(CCObject* pObject);  
//创建array并设置容量  
static CCArray* createWithCapacity(unsigned int capacity);  
//用一个已存在的array创建另一个array  
static CCArray* createWithArray(CCArray* otherArray);  
</code></pre>

<p><strong>1.2.添加</strong></p>

<pre><code>//添加一个元素  
void addObject(CCObject* object);  
//添加一个已存在array中所有元素  
void addObjectsFromArray(CCArray* otherArray);  
//在指定位置插入元素  
void insertObject(CCObject* object, unsigned int index);  
</code></pre>

<p><strong>1.3.删除</strong></p>

<pre><code>//移除最后一个元素  
void removeLastObject(bool bReleaseObj = true);  
//移除某个元素  
void removeObject(CCObject* object, bool bReleaseObj = true);  
//移除一个指定位置的元素  
void removeObjectAtIndex(unsigned int index, bool bReleaseObj = true);  
//移除某个array  
void removeObjectsInArray(CCArray* otherArray);  
//移除所有元素  
void removeAllObjects();  
//快速移除某个元素  
void fastRemoveObject(CCObject* object);  
//快速移除某个指定位置的元素  
void fastRemoveObjectAtIndex(unsigned int index);  
</code></pre>

<p><strong>1.4.操作元素</strong></p>

<pre><code>//返回元素个数  
unsigned int count() const;  
//返回array容量  
unsigned int capacity() const;  
//返回指定CCObject的位置，如果不存在返回UINT_MAX  
unsigned int indexOfObject(CCObject* object) const;  
//返回指定位置的CCObject  
CCObject* objectAtIndex(unsigned int index);  
//返回最后一个元素  
CCObject* lastObject();  
//返回随机元素  
CCObject* randomObject();  
//返回某个元素是否存在于array中  
bool containsObject(CCObject* object) const;  
//判断array是否相等  
bool isEqualToArray(CCArray* pOtherArray);  
</code></pre>

<p><strong>1.5.操作array内容</strong></p>

<pre><code>//交换2个元素  
void exchangeObject(CCObject* object1, CCObject* object2);  
//交换2个指定位置元素  
void exchangeObjectAtIndex(unsigned int index1, unsigned int index2);  
//用一个对象替代指定位置元素  
void replaceObjectAtIndex(unsigned int uIndex, CCObject* pObject, bool bReleaseObject = true);  
//反转array  
void reverseObjects();  
//收缩array内存以匹配元素个数  
void reduceMemoryFootprint();  
</code></pre>

<h3>2.remove和fastremove</h3>

<p>从<strong>1.3</strong>可以看出删除有两种方式，普通删除和快速删除，它们有什么区别呢？</p>

<p><strong>2.1.普通删除</strong></p>

<pre><code>//普通删除  
void ccArrayRemoveObjectAtIndex(ccArray *arr, unsigned int index, bool bReleaseObj/* = true*/)  
{  
    CCAssert(arr &amp;&amp; arr-&gt;num &gt; 0 &amp;&amp; index &lt; arr-&gt;num, "Invalid index. Out of bounds");  
    //删除元素内容，位置仍保留着  
    if (bReleaseObj)  
    {  
        CC_SAFE_RELEASE(arr-&gt;arr[index]);  
    }  
    //长度减1  
    arr-&gt;num--;  
    //获得要删除的元素后的元素个数  
    unsigned int remaining = arr-&gt;num - index;  
    if(remaining&gt;0)  
    {  
        //将要删除元素后的所有元素逐个向前移动  
        memmove((void *)&amp;arr-&gt;arr[index], (void *)&amp;arr-&gt;arr[index+1], remaining * sizeof(CCObject*));  
    }  
}  
</code></pre>

<p><strong>2.2.快速删除</strong></p>

<pre><code>//快速删除  
void ccArrayFastRemoveObjectAtIndex(ccArray *arr, unsigned int index)  
{  
    //删除元素内容，位置仍保留着  
    CC_SAFE_RELEASE(arr-&gt;arr[index]);  
    //获取最后一个元素  
    unsigned int last = --arr-&gt;num;  
    //把最后一个元素插到删除元素的位置上  
    arr-&gt;arr[index] = arr-&gt;arr[last];  
}  
</code></pre>

<p><strong>2.3.总结</strong></p>

<p>如果有array={0,1,2,3,4,5}，如果要删除3，使用普通删除得到的结果{0,1,2,4,5}，使用快速删除得到的结果是{0,1,2,5,4}。可以看出快速删除的效率比普通删除效率高，就差在移动元素的时间复杂度上。</p>

<h3>3.内存分配</h3>

<p><strong>3.1.容量和个数</strong>
CCArray中容量和个数并不是同一个概念。个数&lt;=容量。从添加元素的源码中可以看到在添加之前会先进行空间分配，所以它是一个动态分配内存的过程。如下</p>

<pre><code>void ccArrayEnsureExtraCapacity(ccArray *arr, unsigned int extra)//确保有额外的空间  
{  
    while (arr-&gt;max &lt; arr-&gt;num + extra)//判断空间是否足够  
    {  
        ccArrayDoubleCapacity(arr);//增加一倍空间  
    }  
}  
</code></pre>

<p>所以，每次CCArray在插入数据时检测到空间不足会增加一倍空间，再进行检测，直到空间满足分配为止。</p>

<p><strong>3.2.判等</strong></p>

<p>判断2个CCArray是否相等使用isEqualToArray()，判断相等的条件是CCArray中的每个元素相等即可，与CCArray的容量无关。</p>

<h3>4.效率</h3>

<p>比起NSMutableArray，CCArray效率能高出10%左右，原因有三：</p>

<p><em>（1）它使用的是C接口，所以它不有Objective-C消息开销。</em></p>

<p><em>（2）它假定你知道你在做什么，所以它不花时间在安全检查上（如边界溢出，空间需求等）。</em></p>

<p><em>（3）在比较上使用了指针而不是isEqual。</em></p>

<p>除了CCArray，我们还看到了ccCArray，CCArray基本上都是调用了ccCArray的函数，为什么要分为2种？
仔细看一下CCArray是继承于CCObject，所以CCArray是用于处理cocos2d-x对象的，内存管理上也有cocos2d-x的autorelease等诸多特性。而ccCArray可以直接操作标准的C数据结构和类型。</p>

<h3>5.CCARRAY_FOREACH和CCARRAY_FOREACH_REVERSE</h3>

<p>宏定义，用于正向遍历和反向遍历CCArray元素</p>

<pre><code>#define CCARRAY_FOREACH(__array__, __object__)                                                                         \  
    if ((__array__) &amp;&amp; (__array__)-&gt;data-&gt;num &gt; 0)                                                                     \  
    for(CCObject** __arr__ = (__array__)-&gt;data-&gt;arr, **__end__ = (__array__)-&gt;data-&gt;arr + (__array__)-&gt;data-&gt;num-1;    \  
    __arr__ &lt;= __end__ &amp;&amp; (((__object__) = *__arr__) != NULL/* || true*/);                                             \  
    __arr__++)  

#define CCARRAY_FOREACH_REVERSE(__array__, __object__)                                                                  \  
    if ((__array__) &amp;&amp; (__array__)-&gt;data-&gt;num &gt; 0)                                                                      \  
    for(CCObject** __arr__ = (__array__)-&gt;data-&gt;arr + (__array__)-&gt;data-&gt;num-1, **__end__ = (__array__)-&gt;data-&gt;arr;     \  
    __arr__ &gt;= __end__ &amp;&amp; (((__object__) = *__arr__) != NULL/* || true*/);                                              \  
    __arr__--)  
</code></pre>

<h3>6.示例</h3>

<p>CCArray的使用示例在<a href="http://blog.csdn.net/jackystudio/article/details/11917875">此文</a>中有比较典型的应用，这里就不再详述。</p>

<h3>7.注意</h3>

<p>一般来说，CCArray不会被add到其他类，所以它的引用计数是1，而且被设置为自动释放。所以创建CCArray对象时要记得调用retain，而且在析构的时候也要调用release来释放内存。真心想吐槽。。。</p>
]]></content>
  </entry>
  
</feed>
