<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cocos2d-x | Jacky's Blog]]></title>
  <link href="http://www.jacky.tk/blog/categories/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://www.jacky.tk/"/>
  <updated>2013-11-11T16:35:02+08:00</updated>
  <id>http://www.jacky.tk/</id>
  <author>
    <name><![CDATA[FuSijie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十五】关卡选择的设计]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/23/play-cocos2dx-15/"/>
    <updated>2013-10-23T16:26:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/23/play-cocos2dx-15</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/12966993">http://blog.csdn.net/jackystudio</a></p>

<p>这节介绍一下游戏中帮助界面和关卡选择的设计，其实都是一样的，关键在于美工。这里采用自定义TableView层来实现。</p>

<h3>1.导入头文件和设定空间</h3>

<p>因为TableView相关的类是在扩展包里面，所以必须先声明</p>

<pre><code>#include "cocos-ext.h"  
USING_NS_CC_EXT;  
</code></pre>

<!-- more -->


<h3>2.继承的实现</h3>

<p>自定义TableView继承于CCLayer，因此可以捕获触摸，同时继承于扩展包的CCTableViewDataSource和CCTableViewDelegate。前者是TableView的数据源，包含了一系列和TableView数据单元相关的操作，后者则是继承于CCScrollViewDelegate抽象类，声明了一些和滚动，放大，触摸回调之类的接口，然后在内部包含了一个CCTableView，这用起来有点像Android的Adapter。当然分别继承几个类使用也是一样的。</p>

<p>先看一下要实现的接口吧。</p>

<pre><code>class TableViewTestLayer : public cocos2d::CCLayer, public cocos2d::extension::CCTableViewDataSource, public cocos2d::extension::CCTableViewDelegate  
{  
    public:  
    virtual bool init();    

    CREATE_FUNC(TableViewTestLayer);  

    virtual void scrollViewDidScroll(cocos2d::extension::CCScrollView* view){}//滚动时调用，空实现，因为继承了抽象类所以必须重写  
    virtual void scrollViewDidZoom(cocos2d::extension::CCScrollView* view){}//缩放时调用，空实现，同上  
    virtual void tableCellTouched(cocos2d::extension::CCTableView* table, cocos2d::extension::CCTableViewCell* cell);//触摸单元时回调  
    virtual cocos2d::CCSize tableCellSizeForIndex(cocos2d::extension::CCTableView *table, unsigned int idx);//设定单元所占大小  
    virtual cocos2d::extension::CCTableViewCell* tableCellAtIndex(cocos2d::extension::CCTableView *table, unsigned int idx);//设定单元内容  
    virtual unsigned int numberOfCellsInTableView(cocos2d::extension::CCTableView *table);//返回单元数  
};  
</code></pre>

<p>当然还有一些其他功能，如高亮，循环，看情况重载。</p>

<h3>3.自定义TabView层各模块的实现</h3>

<p><strong>3.1.初始化函数init</strong></p>

<pre><code>CCSize winSize = CCDirector::sharedDirector()-&gt;getWinSize();  
CCTableView* tableView = CCTableView::create(this, winSize);//创建一个CCTableView  
tableView-&gt;setDirection(kCCScrollViewDirectionHorizontal);//设置方向  
tableView-&gt;setPosition(ccp(0,winSize.height/2-50));  
tableView-&gt;setDelegate(this);//这句话很重要，把taleView和当前类绑到一起，所以后面的调用主体都是tableView  
this-&gt;addChild(tableView);  
tableView-&gt;reloadData();  
</code></pre>

<p><strong>3.2.触摸回调tableCellTouched</strong></p>

<pre><code>void TableViewTestLayer::tableCellTouched(CCTableView* table, CCTableViewCell* cell)  
{  
    CCLOG("cell touched at index: %i", cell-&gt;getIdx());//cell为当前选择单元  
}  
</code></pre>

<p><strong>3.3.单元大小tableCellSizeForIndex</strong></p>

<pre><code>CCSize TableViewTestLayer::tableCellSizeForIndex(CCTableView *table, unsigned int idx)  
{  
    //if (idx == 2) {  
    //    return CCSizeMake(100, 100);//第2个大小为100，100  
    //}  
    return CCSizeMake(120, 120);其余为120，120  
}  
</code></pre>

<p><strong>3.4.设置数据源tableCellAtIndex</strong></p>

<pre><code>CCTableViewCell* TableViewTestLayer::tableCellAtIndex(CCTableView *table, unsigned int idx)  
{  
    CCString *string = CCString::createWithFormat("%d", idx);  
    CCTableViewCell *cell = table-&gt;dequeueCell();  
    if (!cell) {  
        cell = new CCTableViewCell();//创建单元，如果要自定义单元效果，需继承CCTableViewCell，并重载draw函数  
        cell-&gt;autorelease();  
        CCSprite *sprite = CCSprite::create("HelloWorld.png");  
        sprite-&gt;setScale(0.2f);  
        sprite-&gt;setPosition(ccp(60, 60));  
        sprite-&gt;setTag(123);  
        cell-&gt;addChild(sprite);//添加到cell  
        CCLabelTTF *label = CCLabelTTF::create(string-&gt;getCString(), "Helvetica", 20.0);  
        label-&gt;setPosition(ccp(60,10));  
        label-&gt;setTag(456);  
        cell-&gt;addChild(label);//添加到cell  
    }  
    else  
    {  
        CCLabelTTF *label = (CCLabelTTF*)cell-&gt;getChildByTag(456);  
        label-&gt;setString(string-&gt;getCString());  
    }  
    return cell;  
}  
</code></pre>

<p><strong>3.5.单元数numberOfCellsInTableView</strong></p>

<pre><code>unsigned int TableViewTestLayer::numberOfCellsInTableView(CCTableView *table)  
{  
    return 20;//直接返回设定单元数  
}  
</code></pre>

<h3>4.效果图</h3>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_15/1.jpg" alt="" border="0" title="选项1" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_15/2.jpg" alt="" border="0" title="选项2" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_15/3.jpg" alt="" border="0" title="选项3" /><br></br></div>


<h3>5.源码下载地址</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6422401">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十四】菜单选项卡的实现]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/22/play-cocos2dx-14/"/>
    <updated>2013-10-22T10:34:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/22/play-cocos2dx-14</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/12940733">http://blog.csdn.net/jackystudio</a></p>

<p>有时候，我们希望实现一个选项卡功能，就是切换tab选项，场景中的内容会跟着改变，但是tab选项卡不动。这是用切换场景的方式没办法做到的。
这里我们就可以使用CCLayerMultiplex来实现这个功能。</p>

<h3>1.创建布景</h3>

<p>这里创建3个布景来做示范。分别是Laye1，Layer2和Layer3。代码就不贴了，布景内容可以直接使用HelloWorld的代码。</p>

<!-- more -->


<h3>2.创建主场景</h3>

<p>主场景的初始化函数如下：</p>

<pre><code>bool CCMainScene::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCScene::init());  

        _layer1=CCLayer1::create();//创建3个层的实例  
        _layer2=CCLayer2::create();  
        _layer3=CCLayer3::create();  

        _layerMuticomplex=CCLayerMultiplex::create(_layer1,_layer2,_layer3,NULL);//创建多层布景层  
        this-&gt;addChild(_layerMuticomplex);//添加到场景，默认显示第一个布景  

        CCSize visibleSize = CCDirector::sharedDirector()-&gt;getVisibleSize();  
        CCPoint origin = CCDirector::sharedDirector()-&gt;getVisibleOrigin();  

        CCMenuItemImage *pCloseItem1 = CCMenuItemImage::create(//创建3个tab菜单，用于切换布景  
            "w_b.png",  
            "w_b.png",  
            this,  
            menu_selector(CCMainScene::menuCallback));  

        CCMenuItemImage *pCloseItem2 = CCMenuItemImage::create(  
            "r_b.png",  
            "r_b.png",  
            this,  
            menu_selector(CCMainScene::menuCallback));  

        CCMenuItemImage *pCloseItem3 = CCMenuItemImage::create(  
            "g_b.png",  
            "g_b.png",  
            this,  
            menu_selector(CCMainScene::menuCallback));  

        // create menu, it's an autorelease object  
        pCloseItem1-&gt;setTag(0);//给tab按钮设置tag，方便回调函数中的获取  
        pCloseItem2-&gt;setTag(1);  
        pCloseItem3-&gt;setTag(2);  
        CCMenu* pMenu = CCMenu::create(pCloseItem1, pCloseItem2, pCloseItem3, NULL);//创建菜单  
        pMenu-&gt;alignItemsHorizontallyWithPadding(-1);//设置菜单项间隔  
        pMenu-&gt;setPosition(visibleSize.width/2,25);  
        this-&gt;addChild(pMenu, 1);//注意哦，菜单要在场景中添加而不是在布景中了！而且z轴要高于多层布景，保证可见。  
        bRet=true;  
    } while (0);  
    return bRet;  
}  
</code></pre>

<p>回调函数如下：</p>

<pre><code>void CCMainScene::menuCallback(CCObject* pSender)  
{  
    int item=((CCMenuItemImage*)pSender)-&gt;getTag();//获取选择项  
    if (item!=curLayerPos)  
    {  
        _layerMuticomplex-&gt;switchTo(item);//切换布景，如果使用switchToAndReleaseMe会释放掉当前布景  
        curLayerPos=item;  
    }  
}  
</code></pre>

<h3>3.效果</h3>

<p>为了让效果明显一点，我让3个布景稍微有点区别。当然菜单是可以做normal，pressed，disable三态的，这里略去。点击不同的选项卡就可以切换到不同的布景层。当然CCLayerMultiplex还可以嵌套使用。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_14/1.jpg" alt="" border="0" title="效果" /><br></br></div>


<h3>4.源码下载地址</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6421801">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十三】CCMenu的布局]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/21/play-cocos2dx-13/"/>
    <updated>2013-10-21T10:23:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/21/play-cocos2dx-13</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/12904705">http://blog.csdn.net/jackystudio</a></p>

<p>前两天写个游戏，发现CCMenu的布局还是比较有意思的，这里总结一下，以便后用。</p>

<h3>1.概况</h3>

<p>CCMenu是cocos2d-x的菜单类，但它本身并不具备菜单具体属性，而是作为一个父节点，将一些具体类型的菜单添加进去来达到菜单目的的。我们正常会这么使用它：先创建子菜单项CCMenuItem，然后将子菜单项CCMenuItem加入菜单CCMenu，最后把CCMenu加入当前层CCLayer。</p>

<p>如果直接在层中添加CCMenuItem会怎样？其实显示也是会正常，但是无法响应回调，因为CCMenu是继承至CCLayer，也就继承了触摸的相关事件，而CCMenuItem只是从CCNode继承而来，并不响应触摸，因此无法调用回调函数。</p>

<!-- more -->


<h3>2.菜单CCMenu</h3>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_13/1.jpg" alt="" border="0" title="CCMenu" /><br></br></div>


<h3>3.子菜单项CCMenuItem</h3>

<p>子菜单项可以是用精灵，图片，标签文本，或者开关都可以，这里不具体解释。请看：</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_13/2.jpg" alt="" border="0" title="CCMenuItem" /><br></br></div>


<h3>4.锚点</h3>

<p>CCMenu继承于CCLayer，所以它具有忽略锚点的属性。而CCMenuItem的锚点是正常的(0.5,0.5)。</p>

<p>（1）看一下自带的HelloCpp这个工程，在添加退出按钮的时候，是不是有这么一句：</p>

<pre><code>pMenu-&gt;setPosition(CCPointZero);
</code></pre>

<p>这句话的作用就是把Menu放在原点的位置，假设Menu有大小，那就是下图1。</p>

<p>（2）现在再做点改变，把MenuItem指定的位置去掉，也就是让它默认在(0,0)位置上。</p>

<pre><code>//pCloseItem-&gt;setPosition(ccp(origin.x + visibleSize.width - pCloseItem-&gt;getContentSize().width/2 ,origin.y + pCloseItem-&gt;getContentSize().height/2));  
</code></pre>

<p>那么再看一下效果，如图2，抽象出来就是图3，因为CCMenuItem的锚点是(0.5,0.5)。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_13/3.jpg" alt="" border="0" title="" /><br></br></div>


<p>（3）所以现在可以理解HelloCpp中为什么定义的是CCMenuItem的位置，而不是定义CCMenu的位置了吧。CCMenu包含了多个子菜单项，每个子菜单的位置都不一样，如果定义了CCMenu的位置，那它作为父节点会影响到所有的子菜单的位置，因此我们一般把它设置在原点处，然后通过设置子菜单的位置（也就是相对父节点的偏移量）来定位整个菜单。</p>

<h3>5.多子菜单的排列</h3>

<p><em>（1）横向排列，纵向排列，可以指定间隔</em></p>

<pre><code>CCMenuItemImage *pCloseItem1 = CCMenuItemImage::create(  
    "CloseNormal.png",  
    "CloseSelected.png",  
    this,  
    menu_selector(HelloWorld::menuCloseCallback));  
CCMenuItemImage *pCloseItem2 = CCMenuItemImage::create(  
    "CloseNormal.png",  
    "CloseSelected.png",  
    this,  
    menu_selector(HelloWorld::menuCloseCallback));  

CCMenu* pMenu = CCMenu::create(pCloseItem1,pCloseItem2,NULL);  
pMenu-&gt;alignItemsHorizontally();//默认间隔是kDefaultPadding=5  
//pMenu-&gt;alignItemsHorizontallyWithPadding(20);//指定间隔  
//pMenu-&gt;alignItemsVertically();//默认间隔也是kDefaultPadding=5  
//pMenu-&gt;alignItemsVerticallyWithPadding(20);//指定间隔  
this-&gt;addChild(pMenu, 1);  
</code></pre>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_13/4.jpg" alt="" border="0" title="" /><br></br></div>


<p><em>（2）按行排列，按列排列，不能指定间隔，只能自己实现。希望下一版本有这个功能。</em></p>

<pre><code>CCMenuItemImage *pCloseItem1 = CCMenuItemImage::create(  
    "CloseNormal.png",  
    "CloseSelected.png",  
    this,  
    menu_selector(HelloWorld::menuCloseCallback));  
...  
CCMenuItemImage *pCloseItem6 = CCMenuItemImage::create(  
    "CloseNormal.png",  
    "CloseSelected.png",  
    this,  
    menu_selector(HelloWorld::menuCloseCallback));  
CCMenu* pMenu = CCMenu::create(pCloseItem1,pCloseItem2,pCloseItem3,pCloseItem4,pCloseItem5,pCloseItem6,NULL);  
pMenu-&gt;alignItemsInRows(3,2,1,NULL);  
//pMenu-&gt;alignItemsInColumns(3,2,1,NULL);  
this-&gt;addChild(pMenu, 1);  
</code></pre>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_13/5.jpg" alt="" border="0" title="" /><br></br></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十二】plist解析工具：Anti_TexturePacker]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/19/play-cocos2dx-12/"/>
    <updated>2013-10-19T09:49:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/19/play-cocos2dx-12</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/12867863">http://blog.csdn.net/jackystudio</a></p>

<p>之前拿了一些别人的图片素材，是用TexturePacker打包合成的，结果写程序的时候不知道每个合成前小png图的名字是什么，只能一个一个从plist文件中找，然后猜测对应的名字，再进行显示，如果不对，还要继续猜。。。坑爹啊，效率大大降低了，时间都耗在找图片名字上了。后来决定动手写一个解析plist的软件，就叫它Anti_TexturePacker吧。</p>

<p>Anti_TexurePacker软件基于VS 2008 MFC Dialog。</p>

<h3>1.PNG图的显示</h3>

<p>这个还好，VS2008提供了GDI+，所以可以直接用它显示。关键是屏幕尺寸有限，如果打包后的PNG图很大的话，不能直接显示，又懒得做滚动条，所以直接采用缩放的方式了。缩放比例较大的话，可能会出现捕获点计算不精确，不过效果还是不错的，没有尺寸限制。</p>

<!-- more -->


<pre><code>CDC* pDC =GetDC();  
Graphics graphics( pDC-&gt;m_hDC);  
Image image(m_PNGFileName.GetString(), FALSE);  
graphics.DrawImage(&amp;image,ORIGIN_DRAW_X,ORIGIN_DRAW_Y,(int)(m_RealWidth*m_ScaleRatio),(int)(m_RealHeight*m_ScaleRatio)); 
</code></pre>

<p>要注意PNG图的显示要放在OnPaint中执行，这样窗口进行重绘的时候才会保证PNG图的正常显示。</p>

<h3>2.plist文件的读取</h3>

<p>看一下plist的格式：</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_12/7.jpg" alt="" border="0" title="xml" /><br></br></div>


<p>这样一看，就知道了标准的plist文件中，我们需要的是第7，10，14，20，23，27&hellip;行。抓出规律，读取到CStringArray。我没有采用xml的解析库，而是直接无耻的这么做了，用起来倒是没什么问题，但是不要学啊。。。</p>

<pre><code>    int i=1;
    int needName=7;
    int needConfig=10;
    int needrotate=14;
    if(!bFileExist)//如果文件存在且可读
    {
        return FALSE;
    }
    CString strline;
    FileContainer.RemoveAll();
    //将PlistFile文件数据读到FileContainer
    while(PlistFile.ReadString(strline))
    {
        if (i==needName)
        {
            FileContainer.Add(strline);
            needName+=13;
        }
        if (i==needConfig)
        {
            FileContainer.Add(strline);
            needConfig+=13;
        }
        if (i==needrotate)
        {
            FileContainer.Add(strline);
            needrotate+=13;
        }
        i++;
    }
    PlistFile.Close();
</code></pre>

<p>然后再解析出CCStringArray中的名字和对应的坐标，尺寸，是否旋转赋值到一个结构体（包含Name，Width，Height，OriginX，OriginY，isRotate）。创建一个CList来储存这些结构体。</p>

<pre><code>while(i&lt;iFileLines)
{
    strline = FileContainer.GetAt(i++);
    strline.TrimLeft();//删除左边的空格
    if (i%3==1)//第1行，储存名字
    {
        str=strline.Mid(5,strline.GetLength()-11);
        t_pngcfg.strName=str;
    }
    else if(i%3==2)//第2行，储存坐标和尺寸
    {
        CString strTemp;
        str=strline.Mid(10,strline.GetLength()-21);
        AfxExtractSubString(strTemp,str,0,',');
        t_pngcfg.originX=_ttoi(strTemp);
        AfxExtractSubString(strTemp,str,1,',');
        strTemp=strTemp.Left(strTemp.GetLength()-1);
        t_pngcfg.originY=_ttoi(strTemp);
        AfxExtractSubString(strTemp,str,2,',');
        strTemp=strTemp.Right(strTemp.GetLength()-1);
        t_pngcfg.width=_ttoi(strTemp);
        AfxExtractSubString(strTemp,str,3,',');
        t_pngcfg.height=_ttoi(strTemp);
    }
    else //第3行，存储旋转属性
    {
        str=strline.Mid(1,strline.GetLength()-3);
        if (str=="true")
        {
            t_pngcfg.isRotate=true;
        }
        else if (str=="false")
        {
            t_pngcfg.isRotate=false;
        }
        m_list.AddTail(t_pngcfg);
    }
}
</code></pre>

<p>因为plist文件最后还有一个metadata字段，所以后面进行遍历的时候要对CCList的个数减1。</p>

<h3>3.随鼠标移动的PNG图片名字的获取</h3>

<p>在OnMouseMove中进行处理显示。</p>

<pre><code>CPoint ptInPNG;  
ptInPNG.x=(point.x-ORIGIN_DRAW_X)/m_ScaleRatio;  
ptInPNG.y=(point.y-ORIGIN_DRAW_Y)/m_ScaleRatio;  

int count=m_plistFile.m_list.GetCount();  
for (int i=0;i&lt;count-1;i++)  
{  
    PNGCfg t_pngcfg=m_plistFile.m_list.GetAt(m_plistFile.m_list.FindIndex(i));  
    if (isPtInRect(ptInPNG,t_pngcfg))  
    {  
        showStastus(t_pngcfg.strName);  
    }  
}  
</code></pre>

<h3>4.单击PNG图拷贝名字到剪切板</h3>

<p>在OnLButtonDown中进行处理拷贝。</p>

<pre><code>if(OpenClipboard()) //首先打开一个剪切板，如果成功则返回非0值  
{
    HANDLE hClip;//声明一个句柄  
    char *pBuf;  
    EmptyClipboard();//置空这个剪切板，且得到剪切板的所有权  
    hClip=GlobalAlloc(GMEM_MOVEABLE,t_pngcfg.strName.GetLength()+1);  
    //申请锁定一块存放数据的内存区域  
    pBuf=(char *)GlobalLock(hClip);//得到指向内存区域的第一个字节指针  
    strcpy(pBuf,(char*)_bstr_t(t_pngcfg.strName.GetBuffer()));//将文本框的值拷贝到内存中  
    GlobalUnlock(hClip);//解除内存锁定  
    SetClipboardData(CF_TEXT,hClip);//设置数据到剪切板中  
    CloseClipboard();//关闭剪切板  
}  
</code></pre>

<h3>5.PNG图的裁剪和保存</h3>

<p>创建一个新的GDI+Bitmap对象，传入图像数据和大小，进行保存即可。</p>

<pre><code>Gdiplus::Rect rcImage(x, y, width, height);  
pWrapBitmap-&gt;LockBits(&amp;rcImage, Gdiplus::ImageLockModeRead, pWrapBitmap-&gt;GetPixelFormat(), &amp;bitmapData);  
pBitmap = new Gdiplus::Bitmap(bitmapData.Width, bitmapData.Height, bitmapData.Stride, PixelFormat32bppARGB, (BYTE*)bitmapData.Scan0);  
pWrapBitmap-&gt;UnlockBits(&amp;bitmapData);  
if (pngcfg.isRotate)  
{  
    pBitmap-&gt;RotateFlip(Rotate270FlipNone);  
}  

CLSID pngClsid;   
GetEncoderClsid(L"image/png", &amp;pngClsid);   
CString strpathName=strClipDir;  
strpathName+="\\";  
strpathName+=pngcfg.strName;  
pBitmap-&gt;Save(strpathName, &amp;pngClsid, NULL);  
delete pBitmap;  
delete pWrapBitmap;  
</code></pre>

<h3>6.效果图</h3>

<p>（1）鼠标移动到小图上，右上角显示当前位置所在的PNG名。单击小图，PNG名自动复制到剪切板。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_12/1.jpg" alt="" border="0" title="1" /><br></br></div>


<p>（2）在列表中选择小图名字，软件自动显示红框。包裹该小图。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_12/2.jpg" alt="" border="0" title="2" /><br></br></div>


<p>（3）点击裁剪PNG，弹出保存路径，选择保存路径确定。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_12/3.jpg" alt="" border="0" title="3" /><br></br></div>


<p>（4）工作线程中处理PNG图的裁剪。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_12/4.jpg" alt="" border="0" title="4" /><br></br></div>


<p>（5）PNG图裁剪成功。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_12/5.jpg" alt="" border="0" title="5" /><br></br></div>


<p>（6）目录下可以看到裁剪后的小图，按照原来名字命名。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_12/6.jpg" alt="" border="0" title="6" /><br></br></div>


<h3>7.下载地址</h3>

<p>v.1.2版</p>

<p>更新说明：</p>

<p><em>1.增加PNG剪裁为小PNG功能</em></p>

<p><em>2.修正列表显示</em></p>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6440769">下载地址</a></p>

<p>v1.1版</p>

<p>更新说明：</p>

<p><em>1.修复旋转属性显示错误bug</em></p>

<p><em>2.修复png相对路径无法显示bug</em></p>

<p><em>3.增加双击列表显示红框功能</em></p>

<p><em>4.简化操作</em></p>

<p><em>5.修改icon</em></p>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6429297">下载地址</a></p>

<p>源码：<a href="https://github.com/fusijie/Anti_TexturePaker.git">https://github.com/fusijie/Anti_TexturePaker.git</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十一】定时器schedule]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/18/play-cocos2dx-11/"/>
    <updated>2013-10-18T08:08:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/18/play-cocos2dx-11</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/12848473">http://blog.csdn.net/jackystudio</a></p>

<p>如果我们想定时执行一个动作怎么办？CCScheduler帮了我们一个大忙。</p>

<h3>1.概况</h3>

<p>CCNode内部封装了一个</p>

<pre><code>CCScheduler *m_pScheduler;  
</code></pre>

<p>正是通过它我们可以很轻松地完成一些定时功能，所以定时器是节点所具备的功能。</p>

<p>定时器分为2种，一种是更新定时器，执行的频率是每帧执行一次，另一种则是自定义回调函数的定时器（最小值是一帧），关于回调函数和函数指针的相关基础可参见<a href="http://blog.csdn.net/jackystudio/article/details/11720325">这里</a>。</p>

<!-- more -->


<h3>2.API</h3>

<pre><code>//更新定时器，每帧调用1次。每个节点只能有1个被调度的update函数  
void scheduleUpdate(void);  
//卸载更新定时器  
void unscheduleUpdate(void);  

//自定义定时器，如果重复调用，那调用间隔会更新，而不会再次调用  
//interval，调用时间间隔，如果为0，建议使用scheduleUpdate  
//repeat，回调函数会被执行repeat+1次，kCCRepeatForever是无限次调用  
//delay，第一次执行前的延时  
void schedule(SEL_SCHEDULE selector, float interval, unsigned int repeat, float delay);  
void schedule(SEL_SCHEDULE selector, float interval);  
void scheduleOnce(SEL_SCHEDULE selector, float delay);  
void schedule(SEL_SCHEDULE selector);  
//卸载自定义定时器  
void unschedule(SEL_SCHEDULE selector);  
void unscheduleAllSelectors(void);  

//恢复所有定时器和动作，OnEnter调用  
void resumeSchedulerAndActions(void);  
//暂停所有定时器和动作，OnExit调用  
void pauseSchedulerAndActions(void);  

//scheduleUpdate每帧调用  
virtual void update(float delta);  
</code></pre>

<h3>3.示例</h3>

<p><strong>3.1.更新定时器</strong></p>

<pre><code>//开启定时器  
this-&gt;scheduleUpdate();  

//虚函数update  
void HelloWorld::update(float delta)  
{  
    CCLog("%f",delta);  
}  

//输出，这里设置了60fps，调用间隔1/60s  
0.016667  
0.016676  
0.016657  
0.016669  
</code></pre>

<p><strong>3.2.自定义定时器</strong></p>

<pre><code>//开启定时器，延时2s执行，执行3+1次，执行间隔1s  
this-&gt;schedule(schedule_selector(HelloWorld::log),1,3,2);  

//回调函数  
void HelloWorld::log(float dt)  
{  
    CCLog("schedule");  
}  

//输出  
2.004532  
1.005827  
1.000238  
1.001019  
</code></pre>

<h3>4.schedule_selector和SEL_SCHEDULE</h3>

<p>看到上面的schedule_selector了吧，这又是个什么玩意？看看它的宏定义。</p>

<pre><code>#define schedule_selector(_SELECTOR) (SEL_SCHEDULE)(&amp;_SELECTOR)  
</code></pre>

<p>原来是把函数指针转化为SEL_SCHEDULE型指针，那SEL_SCHEDULE又是什么？</p>

<pre><code>typedef void (CCObject::*SEL_SCHEDULE)(float);  
</code></pre>

<p>也没啥，就是定义了一个带有float参数函数指针。所以我们在使用自定义Schedule的时候，回调函数一定要记得带上一个float参数，它记录了两次执行的间隔。如果忘了，可是会出现类型转换错误的异常。这种方式在callfunc_selector，menu_selector等也以同样的方式出现。</p>

<h3>5.谁来调用回调函数</h3>

<p>但是有没有发现，如果这个回调函数是个全局函数或者static函数也就算了，偏偏它是个成员函数，成员函数需要实例来调用，可是从调用方法来看，好像没传入调用对象？</p>

<pre><code>this-&gt;schedule(schedule_selector(HelloWorld::log),1,3,2);  
</code></pre>

<p>是的，还记得一开头说的CCNode内部封装的m_pScheduler吗？</p>

<pre><code>CCScheduler *m_pScheduler;  
</code></pre>

<p>原来CCNode帮我们实现了：</p>

<pre><code>void CCNode::schedule(SEL_SCHEDULE selector, float interval, unsigned int repeat, float delay)  
{  
    CCAssert( selector, "Argument must be non-nil");  
    CCAssert( interval &gt;=0, "Argument must be positive");  

    m_pScheduler-&gt;scheduleSelector(selector, this, interval , repeat, delay, !m_bRunning);  
}  
</code></pre>

<p>原来this这个时候被传入了，同时传入的参数还有m_bRunning，m_bRunning表示节点是否在运行中（是否在舞台上），OnEnter的时候赋值true，OnExit的时候赋值false，所以在执行定时器的时候还必须确保节点有在运行。</p>

<p>这样确实用起来怪怪的，所以在cocos2d-x v3.0版本中，参数和函数指针用一个宏打包起来了~</p>

<p>至于CCSchedule内部是怎么实现的，以及CCTimer的触发回调，有兴趣的就自己看看源码吧，我也写不来，源码有点长啊。</p>
]]></content>
  </entry>
  
</feed>
