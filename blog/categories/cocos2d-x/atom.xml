<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cocos2d-x | Jacky's Blog]]></title>
  <link href="http://www.fusijie.com/blog/categories/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://www.fusijie.com/"/>
  <updated>2013-12-18T10:06:21+08:00</updated>
  <id>http://www.fusijie.com/</id>
  <author>
    <name><![CDATA[FuSijie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之三十二】xml的解析]]></title>
    <link href="http://www.fusijie.com/blog/2013/12/18/play-cocos2dx-32/"/>
    <updated>2013-12-18T09:30:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/12/18/play-cocos2dx-32</id>
    <content type="html"><![CDATA[<p>cocos2d-x中对xml的解析是采用的TinyXML库，而对plist的解析同时结合了CCDictionary来处理，这里简单介绍下cocos2d-x中解析xml的两种方式，也是常用的xml两个C++解析库：TinyXML和RapidXML。xml被设计用于数据存储和传输，重点是数据内容本身，而不像html，用于表现数据。</p>

<h3>1.TinyXML</h3>

<p><strong>1.1.概况</strong></p>

<p>TinyXML的<a href="http://www.grinninglizard.com/tinyxml/">主页</a>，本来不打算介绍这个库的，因为它的解析效率并不高，但是鉴于cocos2d-x采用的就是它，所以也稍微写一下它的用法，cocos2d-x使用的是TinyXML2，Github地址<a href="https://github.com/leethomason/tinyxml2">在这里</a>。就是对TinyXML重新进行了封装，具体的区别在其github上也写的很清楚了。</p>

<!-- more -->


<p><strong>1.2.示例</strong></p>

<p>这里不介绍API，因为太多了，在线手册也都有。首先下载TinyXML库，将4个cpp文件和2个h文件加入cocos2d-x中。添加头文件时只需添加"<em>tinyxml.h</em>&ldquo;即可。</p>

<p><strong>1.2.1.xml的创建</strong></p>

<pre><code>void TestLayer::writeTinyXML()  
{  
    TiXmlDocument* myTinyXMLDoc=new TiXmlDocument();//创建文档对象  

    TiXmlElement* rootElement=new TiXmlElement("Jacky");//创建根节点并连接到文档  
    myTinyXMLDoc-&gt;LinkEndChild(rootElement);  

    TiXmlElement* infoElement=new TiXmlElement("Info");//创建info节点并连接到根节点  
    rootElement-&gt;LinkEndChild(infoElement);  

    infoElement-&gt;SetAttribute("Name","Jacky");//为info节点设置属性  
    infoElement-&gt;SetAttribute("QQ","754505629");  
    infoElement-&gt;SetAttribute("E-mail","Geek.Jacky@Gmail.com");  

    TiXmlElement* blogElement=new TiXmlElement("blog");  
    infoElement-&gt;LinkEndChild(blogElement);//创建blog节点并连接到info节点  
    TiXmlText* blogtext=new TiXmlText("http://blog.csdn.net/jackystudio");  
    blogElement-&gt;LinkEndChild(blogtext);//为blog节点添加文本值  

    TiXmlElement* websiteElenment=new TiXmlElement("website");  
    infoElement-&gt;LinkEndChild(websiteElenment);  
    TiXmlText* websitetext=new TiXmlText("http://www.fusijie.com");  
    websiteElenment-&gt;LinkEndChild(websitetext);  

    myTinyXMLDoc-&gt;SaveFile(CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename("testTiny.xml").c_str());//保存xml  

    delete myTinyXMLDoc;  
}  
</code></pre>

<p><strong>1.2.2.xml的读取</strong></p>

<pre><code>void TestLayer::readTinyXML()  
{  
    TiXmlDocument* myTinyXMLDoc=new TiXmlDocument(CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename("testTiny.xml").c_str());  
    myTinyXMLDoc-&gt;LoadFile();  

    TiXmlElement* rootElement = myTinyXMLDoc-&gt;RootElement();  //获取根节点  
    TiXmlElement* infoElement = rootElement-&gt;FirstChildElement();  // 获取Info节点    

    while (infoElement)   
    {  

        TiXmlAttribute* attributeOfinfo = infoElement-&gt;FirstAttribute();  //获得info的属性    
        while ( attributeOfinfo )   
        {    
            CCLOG("%s : %s",attributeOfinfo-&gt;Name(),attributeOfinfo-&gt;Value());//获取所有属性  
            attributeOfinfo = attributeOfinfo-&gt;Next();    
        }  

        TiXmlElement* blogElement = infoElement-&gt;FirstChildElement();//获得blog  
        CCLOG("blog : %s",blogElement-&gt;GetText());    

        TiXmlElement* websiteElement = blogElement-&gt;NextSiblingElement();//获取website    
        CCLOG("website : %s",websiteElement-&gt;GetText());    

        infoElement = infoElement-&gt;NextSiblingElement();//查找下一节点    
    }    
    delete myTinyXMLDoc;    
}  
</code></pre>

<h3>2.RapidXML</h3>

<p><strong>2.1.概况</strong></p>

<p>RapidXML的<a href="http://rapidxml.sourceforge.net/">主页</a>。在其手册中第四节<a href="http://rapidxml.sourceforge.net/manual.html#namespacerapidxml_1performance">comparison with others parsers</a>可以看到在同等条件下它的解析效率是TinyXML的30到60倍，所以如果需要解析大文件的话，RapidXML是不二之选。</p>

<p><strong>2.2.示例</strong></p>

<p>首先下载RapidXML库，将四个hpp文件都加入cocos2d-x中，在包含头文件时，4个hpp都要进行包含。</p>

<p><strong>2.2.1.xml的创建</strong></p>

<pre><code>void TestLayer::writeRapidXML()  
{  
    rapidxml::xml_document&lt;&gt; myRapidXMLDoc;  

    rapidxml::xml_node&lt;&gt;* root = myRapidXMLDoc.allocate_node(rapidxml::node_element,"Jacky",NULL);//创建根节点  
    myRapidXMLDoc.append_node(root);//追加根节点  

    rapidxml::xml_node&lt;&gt;* info = myRapidXMLDoc.allocate_node(rapidxml::node_element,"Info",NULL);//创建info节点  
    info-&gt;append_attribute(myRapidXMLDoc.allocate_attribute("Name","Jacky"));  
    info-&gt;append_attribute(myRapidXMLDoc.allocate_attribute("QQ","754505629"));  
    info-&gt;append_attribute(myRapidXMLDoc.allocate_attribute("E-mail","Geek.Jacky@Gmail.com"));  
    root-&gt;append_node(info);//追加info节点到root  

    //创建blog和website节点并追加到root  
    rapidxml::xml_node&lt;&gt;* blog = myRapidXMLDoc.allocate_node(rapidxml::node_element,"blog","http://blog.csdn.net/jackystudio");  
    info-&gt;append_node(blog);  
    rapidxml::xml_node&lt;&gt;* website = myRapidXMLDoc.allocate_node(rapidxml::node_element,"website","http://www.fusijie.com");  
    info-&gt;append_node(website);  

    //保存xml文档  
    std::string text;  
    rapidxml::print(std::back_inserter(text), myRapidXMLDoc, 0);  
    CCLog(text.c_str());  
    std::ofstream out(CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename("testRapid.xml"));  
    out &lt;&lt; myRapidXMLDoc;  
}  
</code></pre>

<p><strong>2.2.2.xml的读取</strong></p>

<pre><code>void TestLayer::readRapidXML()  
{  
    rapidxml::file&lt;&gt; fdoc(CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename("testRapid.xml").c_str());//读取数据  
    CCLog(fdoc.data());  
    rapidxml::xml_document&lt;&gt; myRapidXMLDoc;  
    myRapidXMLDoc.parse&lt;0&gt;(fdoc.data());//将数据写入xml_document  

    rapidxml::xml_node&lt;&gt;* root = myRapidXMLDoc.first_node();//获取根节点  

    rapidxml::xml_node&lt;&gt;* info = root-&gt;first_node();//获取Info节点  

    rapidxml::xml_attribute&lt;&gt;* info_attr = info-&gt;first_attribute();//获取info属性  
    CCLog("%s:%s",info_attr-&gt;name(),info_attr-&gt;value());  
    CCLog("%s:%s",info_attr-&gt;next_attribute()-&gt;name(),info_attr-&gt;next_attribute()-&gt;value());  
    CCLog("%s:%s",info_attr-&gt;next_attribute()-&gt;next_attribute()-&gt;name(),info_attr-&gt;next_attribute()-&gt;next_attribute()-&gt;value());  

    rapidxml::xml_node&lt;&gt;* blog=info-&gt;first_node();//获取blog节点  
    CCLog("%s:%s",blog-&gt;name(),blog-&gt;value());  

    rapidxml::xml_node&lt;&gt;* website=blog-&gt;next_sibling();//获取website节点  
    CCLog("%s:%s",website-&gt;name(),website-&gt;value());  
}  
</code></pre>

<h3>3.生成xml的文件</h3>

<p>以上2种方式生成的xml文件内容如下：</p>

<pre><code>&lt;Jacky&gt;  
    &lt;Info Name="Jacky" QQ="754505629" E-mail="Geek.Jacky@Gmail.com"&gt;  
        &lt;blog&gt;http://blog.csdn.net/jackystudio&lt;/blog&gt;  
    &lt;website&gt;http://www.fusijie.com&lt;/website&gt;  
    &lt;/Info&gt;  
&lt;/Jacky&gt;  
</code></pre>

<h3>4.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6732361">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之三十一】服务器的网络通信编程]]></title>
    <link href="http://www.fusijie.com/blog/2013/12/17/play-cocos2dx-31/"/>
    <updated>2013-12-17T14:11:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/12/17/play-cocos2dx-31</id>
    <content type="html"><![CDATA[<p>这里采用Apache+php搭建了一个简易服务器，服务端用php语言，客户端采用cocos2d-x的CCHttpClient类通过http方式访问服务端资源。模拟了cocos2d-x提交账户和密码到服务端，服务端校验帐号密码，如果正确返回客户端成功登录，如果错误则返回错误信息，同时在服务端后台保存登录log。第一次接触php，语法上和C/C++还是蛮像的，主要是给出一个cocos2d-x网络实例，代码中并没有做一些防呆纠错措施。</p>

<h3>1.搭建Apache+php网页服务器</h3>

<p>Apche2.2 x86版:<a href="http://pan.baidu.com/s/1vNuLF">下载地址</a></p>

<p>php5.2.17版:<a href="http://pan.baidu.com/s/17sFoN">下载地址</a></p>

<p>搭建过程参见<a href="http://tech.163.com/06/0206/11/299AMBLT0009159K.html">这里</a>，这里就不安装MySQL了。</p>

<!-- more -->


<p>搭建成功后，打开<a href="http://127.0.0.1">http://127.0.0.1</a>，就可以看到"<em>It' works!</em>&ldquo;字样。同时打开Apache monitor监控Apache处于运行状态。我这里使用的80端口。</p>

<h3>2.php收集表单的方式</h3>

<p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE，对应着查改增删，这里介绍GET和POST。</p>

<p>用$_GET获取表单数据，表单数据对任何人都是可见的，比如</p>

<pre><code>http://www.w3school.com.cn/welcome.php?username=jackystudio&amp;password=123
</code></pre>

<p>用$_POST获取表单数据，表单数据则是不可见的，比如</p>

<pre><code>http://www.w3school.com.cn/welcome.php
</code></pre>

<p>详细可见<a href="http://www.w3school.com.cn/php">w3school有关php章节</a>。</p>

<h3>3.服务器php处理代码</h3>

<p>这里我直接修改了主页index.html。会C++应该都能看懂，先是打开一个log.txt，接收到username和password，如果是username是jackystudio，password是123的话，把username和password写入log.txt，并返回登录成功，如果username或password错误时返回登录失败。如果未接收到则返回没有用户名密码。</p>

<p><strong>3.1.采用get方式代码</strong></p>

<pre><code>&lt;html&gt;  
    &lt;body&gt;  
        &lt;?php  
        $open=fopen("log.txt","a" ); //Save password  
        if(isset($_GET["username"]) &amp;&amp; isset($_GET["password"]))  
        {  
            if($_GET["username"]=="jackystudio" &amp;&amp; $_GET["password"]=="123")  
            {  
                fwrite($open,"Username:".$_GET["username"]);  
                fwrite($open,"\r\n");  
                fwrite($open,"Password:".$_GET["password"]);  
                echo "Login Success"; //return to client  
            }  
            else  
            {  
                fwrite($open,"Wrong Username or password!");  
                echo "Login Failed"; //return to client  
            }  
        }  
        else  
        {  
            fwrite($open,"No password");  
            echo "No Username or Password"; //return to client  
        }  
        fclose($open);  
        ?&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre>

<p><strong>3.2.采用post方式代码</strong></p>

<pre><code>&lt;html&gt;  
    &lt;body&gt;  
        &lt;?php  
        $open=fopen("log.txt","a" ); //Save password  
        if(isset($_POST["username"]) &amp;&amp; isset($_POST["password"]))  
        {  
            if($_POST["username"]=="jackystudio" &amp;&amp; $_POST["password"]=="123")  
            {  
                fwrite($open,"Username:".$_POST["username"]);  
                fwrite($open,"\r\n");  
                fwrite($open,"Password:".$_POST["password"]);  
                echo "Login Success"; //return to client  
            }  
            else  
            {  
                fwrite($open,"Wrong Username or password!");  
                echo "Login Failed"; //return to client  
            }  
        }  
        else  
        {  
            fwrite($open,"No password");  
            echo "No Username or Password"; //return to client  
        }  
        fclose($open);  
        ?&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre>

<h3>4.cocos2d-x使用CCHttpClient类进行网络请求</h3>

<p>CCHttpClient的使用这里也不赘述了，请移步官方文档How_to_use_CCHttpClient。这里在上文编辑框和点九图的基础上进行了修改。2个编辑框，分别是username和password。一个按钮点击发送请求。一个文本显示从服务器返回的结果。</p>

<p><strong>4.1.按钮请求处理</strong></p>

<pre><code>void TestLayer::btncallback( CCObject* pSender )  
{  
    bool requestType_is_get=true;//采用get方式或者post方式  
    if (requestType_is_get)  
    {  
        CCHttpRequest* request = new CCHttpRequest();//创建请求对象  
        string str1 = "127.0.0.1:80/index.html?";  
        string str2 = p_User_EditBox-&gt;getText();//获取username编辑框内容  
        string str3 = p_Psw_EditBox-&gt;getText();//获取password编辑框内容  
        string struser="username=";  
        string strpsw="&amp;password=";  
        str1=str1+struser+str2+strpsw+str3;  
        request-&gt;setUrl(str1.c_str());//设置请求的url，username和password已经包含在url中  
        request-&gt;setRequestType(CCHttpRequest::kHttpGet);//设置为Get模式  
        request-&gt;setResponseCallback(this, httpresponse_selector(TestLayer::onHttpRequestCompleted));//设置响应的回调  
        request-&gt;setTag("GET test");  
        CCHttpClient::getInstance()-&gt;send(request);//发送请求  
        request-&gt;release();//释放请求  
    }  
    else  
    {  
        CCHttpRequest* request = new CCHttpRequest();//创建请求对象  
        string str1 = "127.0.0.1:80/index.html";  
        string str2 = p_User_EditBox-&gt;getText();  
        string str3 = p_Psw_EditBox-&gt;getText();  
        string struser="username=";  
        string strpsw="&amp;password=";  
        str2=struser+str2+strpsw+str3;  

        request-&gt;setUrl(str1.c_str());//设置请求的url，只是请求页面的url，并不包含username和password  
        request-&gt;setRequestType(CCHttpRequest::kHttpPost);//设置为Post模式  
        request-&gt;setResponseCallback(this, httpresponse_selector(TestLayer::onHttpRequestCompleted));//设置响应的回调  

        const char* postData = str2.c_str();  
        request-&gt;setRequestData(postData, strlen(postData));//设置请求数据，也就是username和password  

        request-&gt;setTag("POST test");  
        CCHttpClient::getInstance()-&gt;send(request);//发送请求  
        request-&gt;release();//释放请求  
    }  
}  
</code></pre>

<p><strong>4.2.响应回调处理</strong></p>

<pre><code>void TestLayer::onHttpRequestCompleted( CCHttpClient* client, CCHttpResponse* response )  
{  
    if (!response-&gt;isSucceed())//如果响应失败，输出错误信息  
    {    
        CCString strError;  
        strError.initWithFormat("Receive Error! \n%s\n",response-&gt;getErrorBuffer());  
        m_labelStatusCode-&gt;setString(strError.getCString());  
        return ;     
    }    

    std::vector&lt;char&gt; *buffer = response-&gt;getResponseData();//接收响应信息  
    string recieveData;  
    for (unsigned int i = 0; i &lt; buffer-&gt;size(); i++)  
    {    
        recieveData += (*buffer)[i];    
    }  
    size_t begin= recieveData.find("&lt;body&gt;")+6;//这里简单处理，获取&lt;body&gt;标签内数据，即是响应内容  
    size_t end= recieveData.find("&lt;/body&gt;");  
    string result(recieveData,begin,end-begin);  
    m_labelStatusCode-&gt;setString(result.c_str());  
}  
</code></pre>

<h3>5.效果图</h3>

<p><strong>5.1.Apache运行（Get和Post两种效果都是一样的）</strong></p>

<p><em>（1）帐号密码正确时</em></p>

<div align="center"><img src="http://img.blog.csdn.net/20131214145727843" alt="" border="0" title="登录成功" /><br></br></div>


<p><em>（2）帐号密码错误时</em></p>

<div align="center"><img src="http://img.blog.csdn.net/20131214145557531" alt="" border="0" title="登录失败" /><br></br></div>


<p><strong>5.2.关闭Apache</strong></p>

<div align="center"><img src="http://img.blog.csdn.net/20131214145740578" alt="" border="0" title="服务器关闭" /><br></br></div>


<h3>6.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6713471">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之三十】点九图和输入框的使用]]></title>
    <link href="http://www.fusijie.com/blog/2013/12/13/play-cocos2dx-30/"/>
    <updated>2013-12-13T11:53:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/12/13/play-cocos2dx-30</id>
    <content type="html"><![CDATA[<p>登录界面一个帐号/密码输入框或者主角命名框是少不了的。这节就来了解一下点九图的输入框的使用。这里只是介绍基础知识，并不进行平台的移植，也不处理跨平台可能出现的问题。</p>

<h3>1.点九图CCScale9Sprite</h3>

<p><strong>1.1.概述</strong></p>

<p>点九图做过移动开发的肯定不会陌生。采用的是PNG点9图，PNG点9图可以自适应各种环境，同时保持伸缩不变形。移动端的UI基本上都是按这个来做的。点9图的制作很简单，用Android SDK的tool下的draw9patch.bat就可以制作。左为原理图，右为效果图。</p>

<!-- more -->




<div align="center"><img src="http://www.fusijie.com/images/Blog/Play_cocos2dx_30/1.jpg" alt="" border="0" title="点九图" /><br></br></div>


<p><strong>1.2.使用</strong></p>

<p>cocos2d-x采用CCScale9Sprite来处理点九图，CCScale9Sprite为扩展类，所以在使用前需加入如下声明。</p>

<pre><code>#include "cocos-ext.h"  
USING_NS_CC_EXT;
</code></pre>

<p>CCScale9Sprite和CCSprite一样继承于CCNodeRGB，所以基本上可以像使用CCSprite一样使用CCScale9Sprite（有一点小差别CCSprite还继承了CCTextureProtocol接口）。以下用于创建一个二态点九图按钮。</p>

<pre><code>CCScale9Sprite* confirmnormal=CCScale9Sprite::create("btn_style_alert_dialog_button_normal.9.png");//normal态  
confirmnormal-&gt;setContentSize(CCSizeMake(100,70));//设置大小  
CCScale9Sprite* confirmpressd=CCScale9Sprite::create("btn_style_alert_dialog_button_pressed.9.png");//pressd态  
confirmpressd-&gt;setContentSize(CCSizeMake(100,70));//设置大小  
CCMenuItemSprite* menuitem=CCMenuItemSprite::create(confirmnormal,confirmpressd,this,menu_selector(TestLayer::btncallback));  
CCMenu* menu=CCMenu::create(menuitem,NULL);//创建menu  
menu-&gt;setPosition(visibleSize.width/2,visibleSize.height/2);  
this-&gt;addChild(menu);  
</code></pre>

<h3>2.输入框CCEditBox</h3>

<p><strong>2.1.概述</strong></p>

<p>CCEditBox也是cocos2d-x的扩展类，所以和上面一样要进行头文件包含和命名空间声明。另外由于要监控输入框的各种状态，所以还必须实现CCEditBoxDelegate类，该类声明了以下接口：</p>

<pre><code>//当键盘弹出编辑框获得焦点时调用  
virtual void editBoxEditingDidBegin(CCEditBox* editBox) {};  
//当键盘消失编辑框失去焦点时调用  
virtual void editBoxEditingDidEnd(CCEditBox* editBox) {};  
//当编辑框文本改变时调用  
virtual void editBoxTextChanged(CCEditBox* editBox, const std::string&amp; text) {};  
//当返回键按下时或者点击了键盘以外的区域时调用  
virtual void editBoxReturn(CCEditBox* editBox) = 0;  
</code></pre>

<p><strong>2.2.使用</strong></p>

<p>在TestLayer.cpp的init()中创建编辑框。</p>

<pre><code>//bool TestLayer::init()  
CCSize visibleSize=CCDirector::sharedDirector()-&gt;getVisibleSize();  

pEditBox = CCEditBox::create(CCSizeMake(250,50), CCScale9Sprite::create("login_edit_normal.9.png"));  
pEditBox-&gt;setPosition(ccp(visibleSize.width/2, visibleSize.height*3/4));  
pEditBox-&gt;setFontColor(ccRED);//设置字体颜色  
pEditBox-&gt;setPlaceHolder("please input:");//设置预置文本  
pEditBox-&gt;setMaxLength(8);//设置最大长度  

//  kEditBoxInputModeAny: 开启任何文本的输入键盘,包括换行  
//  kEditBoxInputModeEmailAddr:   开启 邮件地址 输入类型键盘  
//  kEditBoxInputModeNumeric: 开启 数字符号 输入类型键盘  
//  kEditBoxInputModePhoneNumber: 开启 电话号码 输入类型键盘  
//  kEditBoxInputModeUrl: 开启 URL 输入类型键盘  
//  kEditBoxInputModeDecimal: 开启 数字 输入类型键盘，允许小数点  
//  kEditBoxInputModeSingleLine:  开启任何文本的输入键盘,不包括换行  
pEditBox-&gt;setInputMode(kEditBoxInputModeAny);//设置输入类型  

//kEditBoxInputFlagPassword:密码形式输入  
//kEditBoxInputFlagSensitive:   敏感数据输入、存储输入方案且预测自动完成  
//kEditBoxInputFlagInitialCapsWord: 每个单词首字母大写,并且伴有提示  
//kEditBoxInputFlagInitialCapsSentence: 第一句首字母大写,并且伴有提示  
//kEditBoxInputFlagInitialCapsAllCharacters:所有字符自动大写  
pEditBox-&gt;setInputFlag(kEditBoxInputFlagPassword);//设置输入标志位  

//  kKeyboardReturnTypeDefault:  默认使用键盘return 类型  
//  kKeyboardReturnTypeDone: 默认使用键盘return类型为“Done”字样  
//  kKeyboardReturnTypeSend: 默认使用键盘return类型为“Send”字样  
//  kKeyboardReturnTypeSearch:   默认使用键盘return类型为“Search”字样  
//  kKeyboardReturnTypeGo:   默认使用键盘return类型为“Go”字样  
pEditBox-&gt;setReturnType(kKeyboardReturnTypeDone);//设置返回类型  
pEditBox-&gt;setDelegate(this);//当前类继承CCEditBoxDelegate类  
addChild(pEditBox);  
</code></pre>

<p>当前类继承于CCEditBoxDelegate，实现其所有接口如下：</p>

<pre><code>void TestLayer::editBoxEditingDidBegin(CCEditBox *editBox)  
{  
    CCLOG("start edit");  
}  
void TestLayer::editBoxEditingDidEnd(CCEditBox *editBox)  
{  
    CCLOG("end edit");  
}  
void TestLayer::editBoxReturn(CCEditBox *editBox)  
{  
    CCLOG("editbox return");  
}  
void TestLayer::editBoxTextChanged(CCEditBox *editBox, const std::string &amp;text)  
{  
    CCLOG("text changed");  
}  
</code></pre>

<h3>3.结合点九图按钮的使用，效果图如下：</h3>

<div align="center"><img src="http://img.blog.csdn.net/20131213102619421" alt="" border="0" title="效果" /><br></br></div>


<h3>4.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6707427">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十九】利用CCClipingNode做游戏遮罩]]></title>
    <link href="http://www.fusijie.com/blog/2013/12/06/play-cocos2dx-29/"/>
    <updated>2013-12-06T10:41:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/12/06/play-cocos2dx-29</id>
    <content type="html"><![CDATA[<p>新手引导是游戏中必备的（除了奇葩的MT用一段动画开始），也是玩家对游戏的第一印象，重要性不言而喻。一般采用的遮罩的形式来突出引导重点，同时屏蔽其他功能。这里简单的介绍一下游戏遮罩的实现，并给出一个示例。</p>

<h3>1.CCClipingNode</h3>

<p>CCClipingNode是一个可裁剪节点，简单理解：</p>

<p><em>（1）首先它是一个节点，继承于CCNode，所以它可以像普通节点一样放入CCLayer，CCScene，CCNode中。</em></p>

<p><em>（2）作为节点，它就可以用作容器，承载其他节点和精灵。我把它叫底板。</em></p>

<p><em>（3）如果想要对一个节点进行裁剪，那需要给出裁剪的部分，这个裁剪区域，我把它叫模版。</em></p>

<!-- more -->


<p>所以CCClipingNode裁剪节点在组成上=底板+模版，而在显示上=底板-模版。不知道这样解释会不会好理解一点。</p>

<div align="center"><img src="http://www.fusijie.com/images/Blog/Play_cocos2dx_29/1.jpg" alt="" border="0" title="CCClipingNode" /><br></br></div>


<h3>2.API</h3>

<p>CCClipingNode的使用还是比较简单的，至于显示底板还是模版，alpha值的设定，这些也不好说清楚，自己多试几次就知道是什么意思该怎么用了。</p>

<pre><code>//不带模版地创建一个裁剪节点  
static CCClippingNode* create();  

//使用一个节点作为模版创建裁剪节点  
static CCClippingNode* create(CCNode *pStencil);  

//不带模版地初始化一个裁剪节点  
virtual bool init();  

//使用一个节点作为模版初始化裁剪节点  
virtual bool init(CCNode *pStencil);  

//设置/获取模版，注意模版需要retain！  
CCNode* getStencil() const;  
void setStencil(CCNode *pStencil);  

//设置alpha值（0~1），这个很重要，裁剪是按像素抠图的，所以只有大于这个alpha值的模版像素才会被画出来  
//默认是1，也就是完全裁剪。  
GLfloat getAlphaThreshold() const;  
void setAlphaThreshold(GLfloat fAlphaThreshold);  

//默认是false，用于设置显示底板还是模版  
bool isInverted() const;  
void setInverted(bool bInverted);  
</code></pre>

<h3>3.示例</h3>

<p>在init中实现：</p>

<pre><code>CCSize visibleSize=CCDirector::sharedDirector()-&gt;getVisibleSize();  

CCSprite* background = CCSprite::create("HelloWorld.png");//创建背景  
background-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2));  
this-&gt;addChild(background,kTagBackground);  

clip=CCClippingNode::create();//创建裁剪节点，成员变量  
clip-&gt;setInverted(true);//设置底板可见  
clip-&gt;setAlphaThreshold(0.0f);//设置alpha为0  
this-&gt;addChild(clip,kTagClipNode);//添加裁剪节点  

CCLayerColor* back=CCLayerColor::create(ccc4(0,0,0,200));  
clip-&gt;addChild(back);//为裁剪节点添加一个黑色带透明（看起了是灰色）的底板  

//模版如果要在其他地方使用要记得retain！  

//第一种：以下模型是drawnode遮罩  
//CCDrawNode* front=CCDrawNode::create();  
//ccColor4F yellow = {1, 1, 0, 1};  
//CCPoint rect[4]={ccp(-30,30),ccp(30,30),ccp(30,-30),ccp(-30,-30)};  
//front-&gt;drawPolygon(rect, 4, yellow, 0, yellow);  
//front-&gt;setPosition(ccp(visibleSize.width/2, visibleSize.height/2));  
//clip-&gt;setStencil(front);  

//第二种：以下模型是带图像遮罩  
CCNode* nodef=CCNode::create();//创建模版  
CCSprite* close=CCSprite::create("CloseSelected.png");//这里使用的是close的那个图标，所以注意观察效果图2  
nodef-&gt;addChild(close);//在模版上添加精灵  
nodef-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2));  
clip-&gt;setStencil(nodef);//设置模版  

tip = CCSprite::create("tip.png");//一些引导提示  
tip-&gt;setScale(0.5f);  
tip-&gt;setRotation(60);  
tip-&gt;setPosition(ccp(visibleSize.width/2-70,visibleSize.height/2+50));  
this-&gt;addChild(tip,kTagTip);  

tip-&gt;runAction(CCRepeatForever::create(CCSequence::create(CCScaleBy::create(0.25f,0.95f),CCScaleTo::create(0.25f,0.5),NULL)));  

this-&gt;setTouchEnabled(true);//触摸有效，落点正确时移除裁剪节点和提示，相关处理请看源码  
</code></pre>

<h3>4.效果</h3>

<p>两种效果：</p>

<div align="center"><img src="http://img.blog.csdn.net/20131206102326578" alt="" border="0" title="1" /><br></br></div>




<div align="center"><img src="http://img.blog.csdn.net/20131206102337937" alt="" border="0" title="2" /><br></br></div>


<h3>5.源码</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6667189">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十八】cocos2d-x的消息和数据传递]]></title>
    <link href="http://www.fusijie.com/blog/2013/12/03/play-cocos2dx-28/"/>
    <updated>2013-12-03T09:57:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/12/03/play-cocos2dx-28</id>
    <content type="html"><![CDATA[<p>如何在层间或者场景间进行消息传递，大概是每个初学者都要面对的问题吧。这里介绍cocos2d-x的一种消息/数据传递方式，内置的观察者模式，也称消息通知中心，CCNotificationCenter。</p>

<h3>1.CCNotificationCenter</h3>

<p>CCNotificationCenter是cocos2d-x提供的一个消息中心，类似于观察者模式，是一个单例类，用于辅助控制消息传递。大概工作原理如下图。</p>

<!-- more -->




<div align="center"><img src="http://www.fusijie.com/images/Blog/Play_cocos2dx_28/1.jpg" alt="" border="0" title="CCNotificationCenter" /><br></br></div>


<p>这里以A，B通讯为例，A，B可以是层间或者场景间。假如A要向B发送带数据的消息。那么</p>

<p><em>（1）B向小心中心注册一个bMsg的消息，告知消息中心，如果消息中心接收到bMsg，必须通知B，以便B采取相应的措施。</em></p>

<p><em>（2）A向消息中心发送bMsg消息。</em></p>

<p><em>（3）消息中心接收到bMsg，查询有谁在它这里注册了这个消息，发现是B，就通知B有人发送了bMsg。</em></p>

<p><em>（4）当然这个消息带有A要传递的数据，而B也不知道到底是谁给它发了bMsg这条消息，除非在传递的数据中指出。</em></p>

<h3>2.相关API</h3>

<pre><code>//获得消息通知中心的一个单例对象  
static CCNotificationCenter *sharedNotificationCenter(void);  

//销毁通知中心的单例对象  
static void purgeNotificationCenter(void);  

//添加观察者  
void addObserver(CCObject *target,   
                SEL_CallFuncO selector,  
                const char *name,  
                CCObject *obj);  

//移除观察者  
void removeObserver(CCObject *target,const char *name);  

//移除所有观察者  
int removeAllObservers(CCObject *target);  

//发送消息  
void postNotification(const char *name);  

//发送带数据的消息  
void postNotification(const char *name, CCObject *object);  
</code></pre>

<p>观察者的意思即是等待获取消息的对象，比如上图的B。</p>

<h3>3.原理</h3>

<p>CCNotificationCenter的实现比较简单，它的内部维护了一个CCArray数组，数组的元素是CCNotificationObserver类型的对象，CCNotificationObserver封装了回调的执行者，回调函数，消息名称以及传递的数据。每次注册，也就是添加观察者，其实就是把这个CCNotificationObserver对象加入通知中心的CCArray数组，而每次的消息发送就是将消息传递给通知中心，由通知中心遍历这个数组，找到一致的消息，调用这些回调函数。其实这样看起来，就像是A在调用B的函数。具体的就自己看下源码吧。</p>

<h3>4.示例</h3>

<p>这里做了一个场景，包含了2个层，目的是层A向层B发送带数据的消息，层B收到后打印出这条数据。</p>

<pre><code>//ALayer  
bool ALayer::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCLayer::init());  
        CCSize visibleSize = CCDirector::sharedDirector()-&gt;getVisibleSize();  
        CCMenuItemImage *pCloseItem = CCMenuItemImage::create(  
            "CloseNormal.png",  
            "CloseSelected.png",  
            this,  
            menu_selector(ALayer::PostMessage));//按钮用于点击发送消息  

        pCloseItem-&gt;setAnchorPoint(ccp(0.5,0.5));  
        pCloseItem-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2));  
        CCMenu* pMenu = CCMenu::create(pCloseItem, NULL);  
        pMenu-&gt;setPosition(CCPointZero);  
        this-&gt;addChild(pMenu, 1);  

        bRet=true;  
    } while (0);  
    return bRet;  
}  

void ALayer::PostMessage(CCObject* pSender)  
{  
    CCString* str=CCString::create("Hello BLayer!");  
    CCNotificationCenter::sharedNotificationCenter()-&gt;postNotification("BMessage",str);//发送带str的消息BMessage  
}  

//BLayer  
bool BLayer::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCLayer::init());  

        CCNotificationCenter::sharedNotificationCenter()-&gt;addObserver(this,callfuncO_selector(BLayer::getMessage),"BMessage",NULL);//注册BMessage，如果接收到了，执行getMessage  

        bRet=true;  
    } while (0);  
    return bRet;  
}  

void BLayer::getMessage(CCObject* obj)  
{  
    CCString* str=static_cast&lt;CCString*&gt;(obj);//打印出传递的数据  
    CCLog(str-&gt;getCString());  
}  

BLayer::~BLayer(void)  
{  
    CCNotificationCenter::sharedNotificationCenter()-&gt;purgeNotificationCenter();//释放通知中心单例对象  
}  
</code></pre>

<h3>5.注意</h3>

<p>使用CCNotificationCenter需要注意以下几点：</p>

<p><em>（1）一个对象可以注册多个消息，一个消息也可以由多个消息注册。</em></p>

<p><em>（2）传递参数，A可以向B传递参数，而B在注册的时候也可以带一个参数，如果这两个数据不是指向同一对象的话，消息不会传递。也就是说要么A传递NULL对象，要么B注册时带NULL对象，要么都不是NULL但必须是同一对象，消息传递才会成功。以下是发送消息执行的判断：</em></p>

<pre><code>if (!strcmp(name,observer-&gt;getName()) &amp;&amp; (observer-&gt;getObject() == object || observer-&gt;getObject() == NULL || object == NULL))  
</code></pre>

<p><em>（3）局部变量的传递，注意到上例，传递的是CCString的一个局部变量（但还是要autorelease），从CCNotificationCenter的实现上来看，这是没有问题的，因为数据是在postNotification被调用的，也就是整个函数体并没结束，数据不会被销毁。</em></p>

<h3>6.效果图</h3>

<div align="center"><img src="http://img.blog.csdn.net/20131204150850171" alt="" border="0" title="效果" /><br></br></div>


<h3>7.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6647453">下载地址</a></p>
]]></content>
  </entry>
  
</feed>
