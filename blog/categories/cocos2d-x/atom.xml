<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cocos2d-x | Jacky's Blog]]></title>
  <link href="http://www.fusijie.com/blog/categories/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://www.fusijie.com/"/>
  <updated>2013-11-28T09:39:12+08:00</updated>
  <id>http://www.fusijie.com/</id>
  <author>
    <name><![CDATA[FuSijie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十七】CCSequence不能执行CCRepeatForever]]></title>
    <link href="http://www.fusijie.com/blog/2013/11/28/play-cocos2dx-27/"/>
    <updated>2013-11-28T09:25:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/11/28/play-cocos2dx-27</id>
    <content type="html"><![CDATA[<p>之前在遇到这么一个问题，在CCSequence中加入CCRepeatForever，发现其他动作执行没问题，就是CCRepeatForever无法执行。代码并没有问题，很奇怪。</p>

<!-- more -->


<h3>1.示例</h3>

<pre><code>CCBlink* blink=CCBlink::create(0.5f,10);//创建闪烁动画，duration=0.5s  
CCAnimation* animation=CCAnimation::create();  
animation-&gt;addSpriteFrameWithFileName("CloseNormal.png");  
animation-&gt;addSpriteFrameWithFileName("CloseSelected.png");  
animation-&gt;setDelayPerUnit(1.0f);//帧间间隔1s  
CCAnimate* animate=CCAnimate::create(animation);//创建帧动画  
CCRepeatForever* repeat=CCRepeatForever::create(animate);  
CCSequence* sequence=CCSequence::create(blink,repeat,NULL);//创建连续动画  
CCSprite* close=CCSprite::create("CloseNormal.png");  
close-&gt;setPosition(ccp(240,160));  
this-&gt;addChild(close);  
close-&gt;runAction(sequence);//执行连续动画  
</code></pre>

<p>结果精灵闪烁10次以后，帧动画不执行了。</p>

<h3>2.原因</h3>

<p>先了解一下CCSequence的创建和执行原理。</p>

<p><strong>2.1.CCSequence的创建</strong></p>

<p>创建CCSequence调用</p>

<pre><code>//创建CCSequence  
CCSequence* CCSequence::create(CCFiniteTimeAction *pAction1, ...)  
</code></pre>

<p>内部调用了createWithVariableList，从实现可以看出这是一个递归调用。</p>

<pre><code>//获取动作列表，创建CCSequence  
CCSequence* CCSequence::createWithVariableList(CCFiniteTimeAction *pAction1, va_list args)  
{  
    CCFiniteTimeAction *pNow;//当前动作  
    CCFiniteTimeAction *pPrev = pAction1;//第一个动作  
    bool bOneAction = true;//只有一个动作的标志位  

    while (pAction1)  
    {  
        pNow = va_arg(args, CCFiniteTimeAction*);//获取当前动作  
        if (pNow)//如果存在  
        {  
            pPrev = createWithTwoActions(pPrev, pNow);//用前两个动作创建CCSequence并赋给第一个动作  
            bOneAction = false;//置false  
        }  
        else//如果不存在  
        {  
            // If only one action is added to CCSequence, make up a CCSequence by adding a simplest finite time action.  
            if (bOneAction)//如果只有一个动作  
            {  
                pPrev = createWithTwoActions(pPrev, ExtraAction::create());  
            }  
        break;//跳出循环  
        }  
    }  
    return ((CCSequence*)pPrev);//返回第一个动作  
}  
</code></pre>

<p>假如有3个动作要被串联，则先把第1个和第2个串联一个CCSequence，再把这个CCSequence和第3个动作串联成最终的CCSequence，然后返回。从CCSequence的成员变量可以看到：</p>

<pre><code>CCFiniteTimeAction *m_pActions[2];//表明只包含2个动作对象指针
</code></pre>

<p>使用递归多少会降低程序的运行效率，但是却可以换来代码的简洁性，同样的CCSpawn也是这么实现的。
在createWithTwoActions中，调用了initWithTwoActions函数，实现了把两个动作串成一个CCSequence，关键代码如下：</p>

<pre><code>float d = pActionOne-&gt;getDuration() + pActionTwo-&gt;getDuration();//获取两个动作的duration  
CCActionInterval::initWithDuration(d);//赋给新的CCSequence  

m_pActions[0] = pActionOne;//同时把两个动作赋给m_pActions指针数组  
pActionOne-&gt;retain();  

m_pActions[1] = pActionTwo;  
pActionTwo-&gt;retain();  
</code></pre>

<p><strong>2.2.duration</strong></p>

<p>从示例可以看出，闪烁动画blink的duration是0.5s，那CCRepeatForever呢？1s？当然不是，1s只是帧动画animate的帧间间隔，每个帧动画包含2帧，而CCRepeatForever的duration是0。因此，当示例中的闪烁动画blink和重复动画repeat串联成CCSequence sequence的时候，sequence的duration就变成0.5+0=0.5s，这很重要。</p>

<p><strong>2.3.m_split</strong></p>

<p>CCSequence中有这么一个成员变量</p>

<pre><code>float m_split;//记录了第一个动画时长占总时长的比例，也就是2个动画的时长分界  
</code></pre>

<p>当执行runAction的时候，CCSequence会调用</p>

<pre><code>void CCSequence::startWithTarget(CCNode *pTarget)  
{  
    CCActionInterval::startWithTarget(pTarget);  
    m_split = m_pActions[0]-&gt;getDuration() / m_fDuration;//获取第一个动画占总时长的比例  
    m_last = -1;  
}  
</code></pre>

<p>而这里由于blink占了0.5s，repeat占了0s，总时长0.5s，所以m_split是0.5/0.5=1。blink占满了整个CCSequence，所以CCSequence无法执行repeat。</p>

<p>这时候再来看CCSequence::update(float dt)函数的执行，就会恍然大悟了。</p>

<pre><code>int found = 0;//当前播放动作索引  
float new_t = 0.0f;//新播放进度  

if( t &lt; m_split ) {//播放进度&lt;分界进度  
    found = 0;//设置当前播放的是第一个动作  
    if( m_split != 0 )//如果第一个动作时长占比!=0  
        new_t = t / m_split;//计算出第一个动作新的播放进度  
    else  
        new_t = 1;//设置第一个已播放完毕  

} else {//播放进度&gt;=分界进度  
    found = 1;//设置当前播放的是第二个动作  
    if ( m_split == 1 )//如果第一个动作时长占比==1  
        new_t = 1;//设置第二个动作已完成  
    else  
        new_t = (t-m_split) / (1 - m_split );//计算出第二个动作新的播放进度  
}  
</code></pre>

<h3>3.注意</h3>

<p><em>（1）CCSpawn也会有这个问题，所以CCSpawn也无法执行加入其中的CCRepeatForever动作。</em></p>

<p><em>（2）CCRepeatForever的反转动作也是无效了，一个不会停止的动作从什么地方开始反转？当然你可以先把动作反转了再加入CCRepeatForever中，这是没问题的。</em></p>

<h3>4.解决方案</h3>

<p><em>（1）对于同时动作，不使用CCSpawn，采用分别执行</em></p>

<pre><code>close-&gt;runAction(blink);  
close-&gt;runAction(repeat);  
</code></pre>

<p><em>（2）对于连续动作，不直接往CCSequence中加入CCRepeatForever，而是把CCRepeatForever放入瞬时动作CCCallFunc中，再把CCCallFunc加入CCSequence中执行。</em></p>

<pre><code>close=CCSprite::create("CloseNormal.png");  
CCBlink* blink=CCBlink::create(0.5f,10);  
CCCallFunc* callFunc=CCCallFunc::create(this,callfunc_selector(TestScene::repeatFunc));//创建CCCallFunc对象  
CCSequence* sequence=CCSequence::create(blink,callFunc,NULL);//把CCCallFunc对象加入CCSequence中  
close-&gt;setPosition(ccp(240,160));  
this-&gt;addChild(close);  
close-&gt;runAction(sequence);  


void TestScene::repeatFunc()  
{  
    CCAnimation* animation=CCAnimation::create();  
    animation-&gt;addSpriteFrameWithFileName("CloseNormal.png");  
    animation-&gt;addSpriteFrameWithFileName("CloseSelected.png");  
    animation-&gt;setDelayPerUnit(1.0f);  
    CCAnimate* animate=CCAnimate::create(animation);  
    CCRepeatForever* repeat=CCRepeatForever::create(animate);  
    close-&gt;runAction(repeat);  
}  
</code></pre>

<p><em>（3）对于CCAnimation帧动画，可以设置循环属性，而不使用CCRepeatForever。</em></p>

<pre><code>animation-&gt;setLoops(-1);  
</code></pre>

<h3>5.总结</h3>

<p>虽然CCRepeatForever也同样继承于CCActionInterval，理论上是延时动作的子类，但是和一般的延时动作又有很大的不同，所以平时在使用的时候必须很小心，不能当成一般的CCActionInterval使用。而在cocos2d-x动作的分类上是不是应该把它从CCAction继承出来会比较好一点？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十五】数据结构CCArray]]></title>
    <link href="http://www.fusijie.com/blog/2013/11/25/play-cocos2dx-25/"/>
    <updated>2013-11-25T13:53:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/11/25/play-cocos2dx-25</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/16938787">http://blog.csdn.net/jackystudio</a></p>

<p>CCArray是从cocos2d中移植过来的，类似于Apple的NSMutableArray，但是比NSMutableArray更为的好用。要注意的是虽然CCArray和CCDictionary可以管理cocos2d-x中绝大多数的类，但是仍然无法替代STL库，STL库更为强有力。</p>

<h3>1.API</h3>

<p>先看一下CCArray可以帮我们做什么。</p>

<!-- more -->


<p><strong>1.1.创建</strong></p>

<pre><code>//创建array  
static CCArray* create();  
//使用一系列CCObject创建array  
static CCArray* create(CCObject* pObject, …);  
//使用一个CCObject创建array  
static CCArray* createWithObject(CCObject* pObject);  
//创建array并设置容量  
static CCArray* createWithCapacity(unsigned int capacity);  
//用一个已存在的array创建另一个array  
static CCArray* createWithArray(CCArray* otherArray);  
</code></pre>

<p><strong>1.2.添加</strong></p>

<pre><code>//添加一个元素  
void addObject(CCObject* object);  
//添加一个已存在array中所有元素  
void addObjectsFromArray(CCArray* otherArray);  
//在指定位置插入元素  
void insertObject(CCObject* object, unsigned int index);  
</code></pre>

<p><strong>1.3.删除</strong></p>

<pre><code>//移除最后一个元素  
void removeLastObject(bool bReleaseObj = true);  
//移除某个元素  
void removeObject(CCObject* object, bool bReleaseObj = true);  
//移除一个指定位置的元素  
void removeObjectAtIndex(unsigned int index, bool bReleaseObj = true);  
//移除某个array  
void removeObjectsInArray(CCArray* otherArray);  
//移除所有元素  
void removeAllObjects();  
//快速移除某个元素  
void fastRemoveObject(CCObject* object);  
//快速移除某个指定位置的元素  
void fastRemoveObjectAtIndex(unsigned int index);  
</code></pre>

<p><strong>1.4.操作元素</strong></p>

<pre><code>//返回元素个数  
unsigned int count() const;  
//返回array容量  
unsigned int capacity() const;  
//返回指定CCObject的位置，如果不存在返回UINT_MAX  
unsigned int indexOfObject(CCObject* object) const;  
//返回指定位置的CCObject  
CCObject* objectAtIndex(unsigned int index);  
//返回最后一个元素  
CCObject* lastObject();  
//返回随机元素  
CCObject* randomObject();  
//返回某个元素是否存在于array中  
bool containsObject(CCObject* object) const;  
//判断array是否相等  
bool isEqualToArray(CCArray* pOtherArray);  
</code></pre>

<p><strong>1.5.操作array内容</strong></p>

<pre><code>//交换2个元素  
void exchangeObject(CCObject* object1, CCObject* object2);  
//交换2个指定位置元素  
void exchangeObjectAtIndex(unsigned int index1, unsigned int index2);  
//用一个对象替代指定位置元素  
void replaceObjectAtIndex(unsigned int uIndex, CCObject* pObject, bool bReleaseObject = true);  
//反转array  
void reverseObjects();  
//收缩array内存以匹配元素个数  
void reduceMemoryFootprint();  
</code></pre>

<h3>2.remove和fastremove</h3>

<p>从<strong>1.3</strong>可以看出删除有两种方式，普通删除和快速删除，它们有什么区别呢？</p>

<p><strong>2.1.普通删除</strong></p>

<pre><code>//普通删除  
void ccArrayRemoveObjectAtIndex(ccArray *arr, unsigned int index, bool bReleaseObj/* = true*/)  
{  
    CCAssert(arr &amp;&amp; arr-&gt;num &gt; 0 &amp;&amp; index &lt; arr-&gt;num, "Invalid index. Out of bounds");  
    //删除元素内容，位置仍保留着  
    if (bReleaseObj)  
    {  
        CC_SAFE_RELEASE(arr-&gt;arr[index]);  
    }  
    //长度减1  
    arr-&gt;num--;  
    //获得要删除的元素后的元素个数  
    unsigned int remaining = arr-&gt;num - index;  
    if(remaining&gt;0)  
    {  
        //将要删除元素后的所有元素逐个向前移动  
        memmove((void *)&amp;arr-&gt;arr[index], (void *)&amp;arr-&gt;arr[index+1], remaining * sizeof(CCObject*));  
    }  
}  
</code></pre>

<p><strong>2.2.快速删除</strong></p>

<pre><code>//快速删除  
void ccArrayFastRemoveObjectAtIndex(ccArray *arr, unsigned int index)  
{  
    //删除元素内容，位置仍保留着  
    CC_SAFE_RELEASE(arr-&gt;arr[index]);  
    //获取最后一个元素  
    unsigned int last = --arr-&gt;num;  
    //把最后一个元素插到删除元素的位置上  
    arr-&gt;arr[index] = arr-&gt;arr[last];  
}  
</code></pre>

<p><strong>2.3.总结</strong></p>

<p>如果有array={0,1,2,3,4,5}，如果要删除3，使用普通删除得到的结果{0,1,2,4,5}，使用快速删除得到的结果是{0,1,2,5,4}。可以看出快速删除的效率比普通删除效率高，就差在移动元素的时间复杂度上。</p>

<h3>3.内存分配</h3>

<p><strong>3.1.容量和个数</strong>
CCArray中容量和个数并不是同一个概念。个数&lt;=容量。从添加元素的源码中可以看到在添加之前会先进行空间分配，所以它是一个动态分配内存的过程。如下</p>

<pre><code>void ccArrayEnsureExtraCapacity(ccArray *arr, unsigned int extra)//确保有额外的空间  
{  
    while (arr-&gt;max &lt; arr-&gt;num + extra)//判断空间是否足够  
    {  
        ccArrayDoubleCapacity(arr);//增加一倍空间  
    }  
}  
</code></pre>

<p>所以，每次CCArray在插入数据时检测到空间不足会增加一倍空间，再进行检测，直到空间满足分配为止。</p>

<p><strong>3.2.判等</strong></p>

<p>判断2个CCArray是否相等使用isEqualToArray()，判断相等的条件是CCArray中的每个元素相等即可，与CCArray的容量无关。</p>

<h3>4.效率</h3>

<p>比起NSMutableArray，CCArray效率能高出10%左右，原因有三：</p>

<p><em>（1）它使用的是C接口，所以它不有Objective-C消息开销。</em></p>

<p><em>（2）它假定你知道你在做什么，所以它不花时间在安全检查上（如边界溢出，空间需求等）。</em></p>

<p><em>（3）在比较上使用了指针而不是isEqual。</em></p>

<p>除了CCArray，我们还看到了ccCArray，CCArray基本上都是调用了ccCArray的函数，为什么要分为2种？
仔细看一下CCArray是继承于CCObject，所以CCArray是用于处理cocos2d-x对象的，内存管理上也有cocos2d-x的autorelease等诸多特性。而ccCArray可以直接操作标准的C数据结构和类型。</p>

<h3>5.CCARRAY_FOREACH和CCARRAY_FOREACH_REVERSE</h3>

<p>宏定义，用于正向遍历和反向遍历CCArray元素</p>

<pre><code>#define CCARRAY_FOREACH(__array__, __object__)                                                                         \  
    if ((__array__) &amp;&amp; (__array__)-&gt;data-&gt;num &gt; 0)                                                                     \  
    for(CCObject** __arr__ = (__array__)-&gt;data-&gt;arr, **__end__ = (__array__)-&gt;data-&gt;arr + (__array__)-&gt;data-&gt;num-1;    \  
    __arr__ &lt;= __end__ &amp;&amp; (((__object__) = *__arr__) != NULL/* || true*/);                                             \  
    __arr__++)  

#define CCARRAY_FOREACH_REVERSE(__array__, __object__)                                                                  \  
    if ((__array__) &amp;&amp; (__array__)-&gt;data-&gt;num &gt; 0)                                                                      \  
    for(CCObject** __arr__ = (__array__)-&gt;data-&gt;arr + (__array__)-&gt;data-&gt;num-1, **__end__ = (__array__)-&gt;data-&gt;arr;     \  
    __arr__ &gt;= __end__ &amp;&amp; (((__object__) = *__arr__) != NULL/* || true*/);                                              \  
    __arr__--)  
</code></pre>

<h3>6.示例</h3>

<p>CCArray的使用示例在<a href="http://blog.csdn.net/jackystudio/article/details/11917875">此文</a>中有比较典型的应用，这里就不再详述。</p>

<h3>7.注意</h3>

<p>一般来说，CCArray不会被add到其他类，所以它的引用计数是1，而且被设置为自动释放。所以创建CCArray对象时要记得调用retain，而且在析构的时候也要调用release来释放内存。真心想吐槽。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十四】截图保存功能的实现]]></title>
    <link href="http://www.fusijie.com/blog/2013/11/13/play-cocos2dx-24/"/>
    <updated>2013-11-13T08:34:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/11/13/play-cocos2dx-24</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/15498083">http://blog.csdn.net/jackystudio</a></p>

<p>官方TestCpp有这个demo了，这里还是把它单独拖出来写一下，游戏推广的一个很重要组成就是玩家分享，所以游戏截图就起到很大作用了。截图功能通过CCRenderTexture实现。</p>

<h3>1.CCRenderTexture</h3>

<p>CCRenderTexture是一个通用渲染对象，可以通过构建一个CCRenderTexture对象，进而把要渲染的东西填充进去，在渲染开始前调用call函数，调用cocos的场景的visit函数对其进行渲染，渲染结束后调用end函数。CCRenderTexture继承于CCNode，所以可以简单地把渲染纹理添加到你的场景中，就像处理其它cocos中的节点一样，当然它还提供了保存功能，可以把渲染纹理保存为PNG或JPG格式。</p>

<!-- more -->


<h3>2.API</h3>

<pre><code>   //创建和初始化函数  
   static CCRenderTexture * create(int w ,int h, CCTexture2DPixelFormat eFormat, GLuint uDepthStencilFormat);  
   static CCRenderTexture * create(int w, int h, CCTexture2DPixelFormat eFormat);  
   static CCRenderTexture * create(int w, int h);  
   bool initWithWidthAndHeight(int w, int h, CCTexture2DPixelFormat eFormat);  
   bool initWithWidthAndHeight(int w, int h, CCTexture2DPixelFormat eFormat, GLuint uDepthStencilFormat);  

   //开始获取  
   void begin();  

   //开始渲染时清除之前渲染的内容  
   void beginWithClear(float r, float g, float b, float a);  
   void beginWithClear(float r, float g, float b, float a, float depthValue);  
   void beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue);  

   //结束获取  
   void end();  

   //清除纹理  
   void clear(float r, float g, float b, float a);  
   void clearDepth(float depthValue);  
   void clearStencil(int stencilValue);  

   //保存纹理为图片文件，可以选择JPG/PNG格式，默认是JPEG格式，成功返回真  
   bool saveToFile(const char *szFilePath);  
   bool saveToFile(const char *name, tCCImageFormat format);  
</code></pre>

<h3>3.示例</h3>

<p>修改HelloWorld中结束菜单的回调函数如下：</p>

<pre><code>void CTestLayer::menuCloseCallback(CCObject* pSender)  
{  
    SaveScreenShot();  
}  

//截图功能  
void CTestLayer::SaveScreenShot()  
{  
    //获取屏幕尺寸  
    CCSize size = CCDirector::sharedDirector()-&gt;getWinSize();  
    //使用屏幕尺寸初始化一个空的渲染纹理对象  
    CCRenderTexture* texture = CCRenderTexture::create((int)size.width, (int)size.height);  
    //设置位置  
    texture-&gt;setPosition(ccp(size.width/2, size.height/2));  
    //开始获取  
    texture-&gt;begin();  
    //遍历场景节点对象，填充纹理到texure中  
    CCDirector::sharedDirector()-&gt;getRunningScene()-&gt;visit();  
    //结束获取  
    texture-&gt;end();  
    //保存为PNG图，Win32/Debug目录下  
    texture-&gt;saveToFile("screenshot.png", kCCImageFormatPNG);  
}  
</code></pre>

<h3>4.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6538305">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十三】cocos2d-x多线程和同步03]]></title>
    <link href="http://www.fusijie.com/blog/2013/11/11/play-cocos2dx-23/"/>
    <updated>2013-11-11T11:22:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/11/11/play-cocos2dx-23</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/15334159">http://blog.csdn.net/jackystudio</a></p>

<p>cocos2d-x中和Android，Windows都一样，如果在主线程中处理一些耗时操作，那么主线程就会出现阻塞现象，表现在界面上就是卡住，未响应等情况。为了避免这种情况的出现，我们需要在后台开辟工作线程进行数据的处理，再采用消息传递或者其他形式来通知主线程进行UI变化。最常见的情况就是游戏进入前的loading。</p>

<h3>1.图片的异步加载</h3>

<p>在多线程和同步的第一篇介绍到使用pthread库的时候，讲到由于CCAutoreleasePool不是线程安全的，所以不能在工作线程中引入cocos2d-x相关的API（其实并不是所有的API都不能使用）。但是cocos2d-x显然考虑到这个问题了，所以它本身就帮我们封装好了一个API，避免了还要手动引入pthread库的尴尬。</p>

<pre><code>void CCTextureCache::addImageAsync(const char *path, CCObject *target, SEL_CallFuncO selector)  
</code></pre>

<!--more -->


<p>其中path是图片的位置，selector是加载完成时的回调函数。很方便，如果需要加载很多图片的话，对每一个进行回调处理，然后在update中更新UI即可。</p>

<h3>2.plist的异步加载</h3>

<p>可是由于内存原因，大部分情况下图片会被合成打包，同时带入plist。这时候如何进行图片的异步加载呢？这个时候就需要对addImageAsync的源码进一步的探究了。</p>

<p><strong>2.1.耗时的是什么？</strong></p>

<p>首先要理解的是耗时的动作是什么，只有把耗时的工作真正抓出来丢到工作线程上，异步加载才有意义。我们知道，图片在内存中是以纹理的形式存在的，而图片的加载，通俗来讲也就是纹理的生成，这就是耗时的原因。那CCTexureCache中addImage（同步加载）和addImageAysnc（异步加载）分别做了什么事？</p>

<p><em>（1）addImage</em>
可以看出addImage使用同步的方式生成了纹理，也就是在主线程中进行了耗时的加载操作。</p>

<pre><code>//...cocos2d-x维护着一个全局纹理，在判断纹理是否已存在  
if (! texture)   
    {  
        do   
        {  
        //...判断图片格式  

            pImage = new CCImage();  
            CC_BREAK_IF(NULL == pImage);  

            bool bRet = pImage-&gt;initWithImageFile(fullpath.c_str(), eImageFormat);  
            CC_BREAK_IF(!bRet);  

            texture = new CCTexture2D();    //开辟纹理空间  

            if( texture &amp;&amp;  
                texture-&gt;initWithImage(pImage) )  //使用CCImage初始化纹理  
            {  
#if CC_ENABLE_CACHE_TEXTURE_DATA  
                // cache the texture file name  
                VolatileTexture::addImageTexture(texture, fullpath.c_str(), eImageFormat);  
#endif  
                m_pTextures-&gt;setObject(texture, pathKey.c_str());  
                texture-&gt;release();  
            }  
            else  
            {  
                CCLOG("cocos2d: Couldn't create texture for file:%s in CCTextureCache", path);  
            }  
        } while (0);  
    }  
//...释放资源，返回纹理  
</code></pre>

<p><em>（2）addImageAsync</em></p>

<p>addImageAsync则是在工作线程中加载图片，然后通过调度器进行纹理的转换。</p>

<pre><code>//创建工作线程用于后台加载图片  
pthread_create(&amp;s_loadingThread, NULL, loadImage, NULL);  

//创建调度队列，用来根据已加载的图片进行纹理转换  
CCDirector::sharedDirector()-&gt;getScheduler()-&gt;scheduleSelector(schedule_selector(CCTextureCache::addImageAsyncCallBack), this, 0, false);  

void CCTextureCache::addImageAsyncCallBack(float dt)  
{  
    //...  
    CCTexture2D *texture = new CCTexture2D();   //开辟纹理空间  
#if 0 //TODO: (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)  
    texture-&gt;initWithImage(pImage, kCCResolutioniPhone);  
#else  
    texture-&gt;initWithImage(pImage);      //使用CCImage初始化纹理  
#endif  

#if CC_ENABLE_CACHE_TEXTURE_DATA  

   VolatileTexture::addImageTexture(texture, filename, pImageInfo-&gt;imageType);  
#endif  
    //...将加入autorelease，进行加载后的回调函数的调用，释放相关资源  
}  
</code></pre>

<p><strong>2.2.plist加载的原理</strong></p>

<p>之前使用plist是这样子的：</p>

<pre><code>void CCSpriteFrameCache::addSpriteFramesWithFile(const char *pszPlist)//传入plist文件即可  
</code></pre>

<p>在它的实现中，发现了这么一句：</p>

<pre><code>CCTexture2D *pTexture = CCTextureCache::sharedTextureCache()-&gt;addImage(texturePath.c_str());  
</code></pre>

<p>原来addSpriteFramesWithFile会先查找是否存在纹理，否则会在.plist的目录下寻找同名图片，然后调用同步的addImage函数来生成纹理。这也就是为什么只加载了plist，而纹理就会存在的原因了。</p>

<p><strong>2.3.异步加载plist</strong></p>

<p>知道了这些，那就让addSpriteFramesWithFile调用异步的addImageAsync函数就可以了，当然不需要改源码，因为CCSpriteFrameCache还提供了如下的plist加载方式：</p>

<pre><code>void CCSpriteFrameCache::addSpriteFramesWithFile(const char *pszPlist, CCTexture2D *pobTexture)  
</code></pre>

<p>所以我们可以手动异步生成纹理后，在回调函数中和.plist一起传入addSpriteFramesWithFile，搞定！还记得刚开始的selector么？生成的纹理会作为参数传入这个回调函数中，完美！</p>

<p><strong>2.4.注意</strong></p>

<p>只要注意一点的是，在使用任何plist中的小图片时，引擎并不会为每一张小图片生成一个纹理，而是共用了大图片的纹理，同时指定了小图片的坐标和长宽。</p>

<h3>3.示例</h3>

<p>其中ui_text.png是大图片，raffle_b_friend.png和raffle_b_diamond.png是两张小图片。</p>

<pre><code>bool CTestLayer::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCLayer::init());  

        //addImage or addImageAsync中创建纹理  
        CCTextureCache::sharedTextureCache()-&gt;addImageAsync("ui_text.png",this,callfuncO_selector(CTestLayer::showSprite));  

        bRet=true;  
    } while (0);  
    return bRet;  
}  

void CTestLayer::showSprite(CCObject* obj)  
{  
    CCTexture2D* texture_ui_text=(CCTexture2D*)obj;//传入的obj即是异步生成的纹理  
    CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;addSpriteFramesWithFile("ui_text.plist",texture_ui_text);//通过纹理和.plist文件加入CCSpriteFrameCache  
    CCSprite* raffle_b_friend=CCSprite::createWithSpriteFrameName("raffle_b_friend.png");//尽情使用小图片吧  
    raffle_b_friend-&gt;setPosition(ccp(100,100));  
    this-&gt;addChild(raffle_b_friend);  

    //错误，只能获取ui_text.png的纹理  
    //CCTexture2D* raffle_b_diamond_texture=CCTextureCache::sharedTextureCache()-&gt;textureForKey("raffle_b_diamond.png");  
    //正确，可以用这种先获取精灵帧，再从精灵帧中获取ui_text的纹理，以及大小，来构建CCSprite  
    CCSpriteFrame* raffle_b_diamond_spriteframe=CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;spriteFrameByName("raffle_b_diamond.png");  
    CCTexture2D* texture=raffle_b_diamond_spriteframe-&gt;getTexture();  
    CCRect rect=raffle_b_diamond_spriteframe-&gt;getRect();  
    CCSprite* raffle_b_diamond=CCSprite::createWithTexture(texture,rect); //如果纹理需要旋转，setRotation吧  
    raffle_b_diamond-&gt;setRotation(false);  
    raffle_b_diamond-&gt;setPosition(ccp(300,100));  
    this-&gt;addChild(raffle_b_diamond);  
}  
</code></pre>

<h3>4.效果</h3>

<p>使用异步加载plist方式处理:</p>

<div align="center"><img src="http://www.fusijie.com/images/Blog/Play_cocos2dx_23/1.jpg" alt="" border="0" title="效果图" /><br></br></div>


<h3>5.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6533293">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十二】cocos2d-x多线程和同步02]]></title>
    <link href="http://www.fusijie.com/blog/2013/11/05/play-cocos2dx-22/"/>
    <updated>2013-11-05T11:12:00+08:00</updated>
    <id>http://www.fusijie.com/blog/2013/11/05/play-cocos2dx-22</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/14161151">http://blog.csdn.net/jackystudio</a></p>

<p>pthread有很多不同应用，官网都有相应的API解释和Sample，这里不再重复，本文主要介绍一个cocos2d-x多线程和同步示例。</p>

<h3>1.售票</h3>

<p>孙鑫老师的C++和Java多线程售票一直让我念念不忘，好吧，这里用cocos2d-x和pthread实现一个吧。总共有100张火车票，有2个售票点A和B再售票，当票卖完了就结束了。我们知道当程序一开始进程就会创建一个主线程，所以可以在主线程基础上再创建2个线程A和B，再线程A和B中分别售票，当票数为0的时候，结束线程A和B。</p>

<!-- more -->


<h3>2.多线程售票</h3>

<pre><code>//TestLayer.h  
class CTestLayer :  
public CCLayer  
{  
    public:  
    CTestLayer(void);  
    ~CTestLayer(void);  

    CREATE_FUNC(CTestLayer);  
    virtual bool init();  

    pthread_t sellA_pid,sellB_pid;//线程id  
    static int tickets;//票数  

    static void* threadA(void* p);//线程A回调  
    static void* threadB(void* p);//线程B回调  
};  


//TestLayer.cpp  
#include "TestLayer.h"  

int CTestLayer::tickets=100;//初始化票数100  
CTestLayer::CTestLayer(void)  
{  
}  


CTestLayer::~CTestLayer(void)  
{  
}  

bool CTestLayer::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCLayer::init());  
        pthread_create(&amp;sellA_pid,NULL,threadA,0);//创建线程A  
        pthread_create(&amp;sellB_pid,NULL,threadB,0);//创建线程B  

        bRet=true;  
    } while (0);  
    return bRet;  
}  

void* CTestLayer::threadA(void* p)  
{  
    while(true)  
    {  
        if(tickets&gt;0)  
        {  
            CCLog("A Sell %d",tickets--);//输出售票，每次减1  
        }  
        else {  
            break;  
        }  
    }  
    return NULL;  
}  

void* CTestLayer::threadB(void* p)  
{  
    while(true)  
    {  
        if (tickets&gt;0)  
        {  
            CCLog("B Sell %d",tickets--);  
        }  
        else   
        {  
            break;  
        }  
    }  
    return NULL;  
}  
</code></pre>

<p>代码很简单，不多说了。我们来看一下输出，会发现有很多不可思议的现象出现，因为每个人每次运行的结果都不一样，所以这里不贴结果了，不可思议的现象可能有：</p>

<p><em>（1）同一张票卖了2次。</em></p>

<p><em>（2）后面的票比前面的票先卖出去。</em></p>

<p><em>（3）第0张票竟然也可以卖。（这算站票么。。。）</em></p>

<p>原因不多解释了，时间片的问题，不明白的Google之。如果你觉得不会有这么巧，那么在打印结果前加上这么一句：</p>

<pre><code>Sleep(100);  
</code></pre>

<p>人为干扰线程的运行，增大出错几率。结果可能会是这样：</p>

<pre><code>A Sell 36  
B Sell 36//卖2次了  
A Sell 35  
B Sell 34  
A Sell 33  
B Sell 32  
A Sell 30//提早卖了  
B Sell 31  
B Sell 28  
A Sell 29  
A Sell 27  
B Sell 26  
A Sell 25  
B Sell 24  
A Sell 23  
B Sell 22  
A Sell 21  
B Sell 20  
A Sell 19  
B Sell 18  
A Sell 17  
B Sell 16  
A Sell 15  
B Sell 14  
A Sell 13  
B Sell 12  
A Sell 11  
B Sell 10  
A Sell 9  
B Sell 8  
A Sell 7  
B Sell 6  
A Sell 5  
B Sell 4  
A Sell 3  
B Sell 2  
A Sell 1  
B Sell 0//站票。。。  
</code></pre>

<h3>3.利用互斥对象同步数据</h3>

<p>这个问题主要是因为一个线程执行到一半的时候，时间片的切换导致另一个线程修改了同一个数据，当再次切换会原来线程并继续往下运行的时候，数据由于被修改了导致结果出错。所以我们要做的就是保证这个线程完全执行完，所以对线程加锁是个不错的注意，互斥对象mutex就是这个锁。</p>

<p><strong>3.1.初始化</strong></p>

<p>在cpp外分配空间：</p>

<pre><code>pthread_mutex_t CTestLayer::mutex;//mutex是静态成员变量  
</code></pre>

<p>在init中初始化，动态初始化：</p>

<pre><code>pthread_mutex_init(&amp;mutex,NULL);  
</code></pre>

<p><strong>3.2.加锁和解锁</strong></p>

<p>以线程A为例：</p>

<pre><code>void* CTestLayer::threadA(void* p)  
{  
    while(true)  
    {  
        pthread_mutex_lock(&amp;mutex);//加锁  
        if(tickets&gt;0)  
        {  
            Sleep(100);  
            CCLog("A Sell %d",tickets--);  
            pthread_mutex_unlock(&amp;mutex);//解锁  
        }  
        else {  
            pthread_mutex_unlock(&amp;mutex);//解锁  
            break;  
        }  
    }  
    return NULL;  
}  
</code></pre>

<p><strong>3.3.释放</strong></p>

<p>在当前层的析构函数中：</p>

<pre><code>pthread_mutex_destroy(&amp;mutex);//前提要保证是解锁状态，否则会返回16的错误，释放失败  
</code></pre>

<p>这个时候再看一下结果，Bingo!</p>

<pre><code>B Sell 16  
A Sell 15  
B Sell 14  
B Sell 13  
B Sell 12  
B Sell 11  
B Sell 10  
B Sell 9  
B Sell 8  
B Sell 7  
B Sell 6  
B Sell 5  
B Sell 4  
B Sell 3  
B Sell 2  
B Sell 1  
</code></pre>

<h3>4.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6503759">下载地址</a></p>
]]></content>
  </entry>
  
</feed>
