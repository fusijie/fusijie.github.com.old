<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cocos2d-x | Jacky's Blog]]></title>
  <link href="http://www.jacky.tk/blog/categories/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://www.jacky.tk/"/>
  <updated>2013-11-11T18:18:35+08:00</updated>
  <id>http://www.jacky.tk/</id>
  <author>
    <name><![CDATA[FuSijie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之二十】从CCObject看cocos2d-x的内存管理机制]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/31/play-cocos2dx-20/"/>
    <updated>2013-10-31T18:13:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/31/play-cocos2dx-20</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/13765639">http://blog.csdn.net/jackystudio</a></p>

<p>再看CCObject，剔除上节的拷贝相关，以及Lua脚本相关的属性和方法后，CCObject还剩下什么？</p>

<h3>1.剩下什么？</h3>

<p>可以看到整个CCObject就是围绕着m_uReference和m_uAutoReleaseCount在转。这两个变量的解释如下。所以CCObject剩下的其实就是对内存的管理。</p>

<!-- more -->


<pre><code>CCObject::CCObject(void)//构造函数  
: m_nLuaID(0)  
, m_uReference(1) //引用计数，初始为1，当引用计数=0，自动释放该对象  
, m_uAutoReleaseCount(0)//自动释放对象计数，如果是手动new的，则为0，如果autoRelease的，则在AutoreleasePool会+1  
                    //这里是保护成员，所以CCAutoreleasePool被声明为友元类  
{  
    static unsigned int uObjectCount = 0;//静态成员，对象的计数，只增不减，用于标识唯一一个对象实例  
    m_uID = ++uObjectCount;                
}  

CCObject::~CCObject(void)  
{  
    if (m_uAutoReleaseCount &gt; 0)//如果是自动管理，则在PoolManager中删除  
    {  
        CCPoolManager::sharedPoolManager()-&gt;removeObject(this);  
    }  

    // if the object is referenced by Lua engine, remove it  
    if (m_nLuaID)  
    {  
        CCScriptEngineManager::sharedManager()-&gt;getScriptEngine()-&gt;removeScriptObjectByCCObject(this);  
    }  
    else  
    {  
        CCScriptEngineProtocol* pEngine = CCScriptEngineManager::sharedManager()-&gt;getScriptEngine();  
        if (pEngine != NULL &amp;&amp; pEngine-&gt;getScriptType() == kScriptTypeJavascript)  
        {  
            pEngine-&gt;removeScriptObjectByCCObject(this);  
        }  
    }  
}  

void CCObject::release(void)//引用计数-1，如果引用计数=0，释放对象  
{  
    CCAssert(m_uReference &gt; 0, "reference count should greater than 0");  
    --m_uReference;  

    if (m_uReference == 0)  
    {  
        delete this;  
    }  
}  

void CCObject::retain(void)//引用计数+1,防止被对象释放  
{  
    CCAssert(m_uReference &gt; 0, "reference count should greater than 0");  

    ++m_uReference;  
}  

CCObject* CCObject::autorelease(void)//对象加入PoolManager，自动管理  
{  
    CCPoolManager::sharedPoolManager()-&gt;addObject(this);  
    return this;  
}  

bool CCObject::isSingleReference(void) const //返回是否唯一引用  
{  
    return m_uReference == 1;  
}  

unsigned int CCObject::retainCount(void) const  //返回引用计数  
{  
    return m_uReference;  
}  

bool CCObject::isEqual(const CCObject *pObject) //判断对象是否相等  
{  
    return this == pObject;  
}  

void CCObject::acceptVisitor(CCDataVisitor &amp;visitor) //辅助对象执行动作  
{  
    visitor.visitObject(this);  
}  
</code></pre>

<h3>2.内存管理</h3>

<p>从CCObject可以看出，内存的管理方式有两种：手动管理和自动管理。</p>

<p><strong>2.1.手动内存管理</strong></p>

<p>想必从Java转到C++的朋友可能很受不了C++再申请完内存后还要手动释放，就像我从C++转Java时也同样很不习惯竟然不用管理内存，老是害怕会不小心让系统给销毁了。CCObject的成员变量m_uAutoReleaseCount标识了是手动管理还是自动管理。如果执行以下操作：</p>

<pre><code>CCObject* obj=new CCObject();//m_uAutoReleaseCount=0,m_uReference=1  
</code></pre>

<p>从析构函数可以看到，析构函数是不对所有手动进行申请的变量进行内存释放（必须m_uAutoReleaseCount>0）。那么这时得手动释放：</p>

<pre><code>obj-&gt;release();//m_uReference-1后为0，执行delete this;  
</code></pre>

<p>所以，new和release是好基友！而手动内存管理一般不再使用retain。</p>

<p><strong>2.2.自动内存管理</strong>
如果需要进行内存的自动管理，那要怎么做呢？</p>

<pre><code>CCObject* obj=new CCObject();//m_uAutoReleaseCount=0,m_uReference=1  
obj-&gt;autorelease();//m_uAutoReleaseCount=1,m_uReference=1  
</code></pre>

<p>好了，什么都不用做，obj自生自灭了。
如果我们需要随时用到obj，而不愿意让它在我们不知情的情况下被释放，那么使用：</p>

<pre><code>obj-&gt;retain();//m_uAutoReleaseCount=1,m_uReference=2  
</code></pre>

<p>当不再需要它的时候，使用：</p>

<pre><code>obj-&gt;release();//m_uAutoReleaseCount=1,m_uReference=1  
</code></pre>

<p>又恢复回去了，所以，retain和release是好基友，一般在自动内存管理使用。</p>

<p>这里只是大概写一下如何使用new，autorelease，retain和release，至于内存管理的实现网上的代码解析很多，发现自己没办法深入浅出地写出来，所以还是放弃再写一回注释了，原理可以这么理解：Cocos2d-x提供了一个内存管理器类CCPoolManager，它包含了一个CCArray容器m_pReleasePoolStack，这个容器用来存放一些容器管理类CCAutoreleasePool的实例对象。需要自动进行内存释放的CCObject实例对象会把其指针存放在容器管理类CCAutoreleasePool的实例对象中的m_pManagedObjectArray容器里。所有存在其中的CCObject实例对象在进行释放操作时通过使用计数器来进行判断在何时真正释放内存，游戏在每一帧结束时都会对autorelease对象进行释放。</p>

<p><strong>2.3.一个疑问</strong>
平时我们可能会这么用：</p>

<pre><code>//CTestLayer.h  
class CTestLayer : public cocos2d::CCLayer  
{  
public:  
    virtual bool init();  

    CREATE_FUNC(CTestLayer);  

    virtual void update(float delta);  

private:  
    CCSprite* background;  
};  

//CTestLayer.cpp  
bool CTestLayer::init()  
{  
    if ( !CCLayer::init() )  
    {  
        return false;  
    }  
    background=CCSprite::create("background.png");  
    this-&gt;addChild(background);  
    this-&gt;scheduleUpdate();  
    return true;  
}  

void update(float delta)  
{  
    background-&gt;setPositionY(background-&gt;getPositionY()-0.1);  
}  
</code></pre>

<p>background是create出来的，可以知道它是调用了autorelease，属于自动管理对象，而且我们又没有进行retain操作，按道理在执行update的时候background已经是要被销毁的，但是实际并没有。问题就出在这一句：</p>

<pre><code>this-&gt;addChild(background);  
</code></pre>

<p>至于为什么，大家翻一下addChild实现源码就知道啦~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十九】从CCObject看cocos2d-x的拷贝机制]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/30/play-cocos2dx-19/"/>
    <updated>2013-10-30T18:08:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/30/play-cocos2dx-19</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/13295505">http://blog.csdn.net/jackystudio</a></p>

<p>CCObject在之前的文章中出现了N次，它扮演了一个老祖宗的角色，但是它到底是做什么的？先从它看看cocos2d-x的拷贝机制吧。</p>

<h3>1.CCCopying</h3>

<p>CCObject从CCCopying继承而来，而CCCopying拥有唯一的一个成员虚函数copyWithZone，这个函数可以认为是拷贝的一个协议，所有继承了CCObject并且需要实现拷贝功能的子类都可以通过它来实现，它的源码很简单，就是一个未实现的断言。CCZone是神马？只是封装了一个CCObject对象指针而已。</p>

<!-- more -->


<pre><code>CCObject* CCCopying::copyWithZone(CCZone *pZone)  
{  
    CC_UNUSED_PARAM(pZone);  
    CCAssert(0, "not implement");  
    return 0;  
}  
</code></pre>

<h3>2.CCObject的子类拷贝问题</h3>

<p>再看看CCObject中copy的实现，是的，直接调用了copyWithZone，所以子类在处理拷贝问题时只需要对copyWithZone进行实现，使用时调用copy即可。</p>

<pre><code>CCObject* CCObject::copy()  
{  
    return copyWithZone(0);  
}  
</code></pre>

<h3>3.CCArray示例</h3>

<p>这里以CCArray的拷贝为例，CCArray继承于CCObject，如上所说，我们只需要实现copyWithZone，然后在拷贝时调用copy即可实现CCArray的拷贝。</p>

<p><strong>3.1.CCArray拷贝时调用copy</strong></p>

<pre><code>CCArray* CCArray::createWithArray(CCArray* otherArray)  
{  
    CCArray* pRet = (CCArray*)otherArray-&gt;copy();//copy调用了copyWithZone  
    pRet-&gt;autorelease();  
    return pRet;  
}  
</code></pre>

<p><strong>3.2.copyWithZone的实现</strong></p>

<p>可以看出CCArray采用的是深拷贝的方式。</p>

<pre><code>CCObject* CCArray::copyWithZone(CCZone* pZone)  
{  
    CCAssert(pZone == NULL, "CCArray should not be inherited.");  
    CCArray* pArray = new CCArray();  //new一个存放拷贝的空间  
    pArray-&gt;initWithCapacity(this-&gt;data-&gt;num &gt; 0 ? this-&gt;data-&gt;num : 1);//初始化一样的长度  

    CCObject* pObj = NULL;  
    CCObject* pTmpObj = NULL;  
    CCARRAY_FOREACH(this, pObj)//遍历CCArray成员  
    {  
        pTmpObj = pObj-&gt;copy();//逐个拷贝  
        pArray-&gt;addObject(pTmpObj);//添加到新拷贝pArray中  
        pTmpObj-&gt;release();  
    }  
    return pArray;//返回拷贝  
}  
</code></pre>

<h3>4.深拷贝和浅拷贝</h3>

<p>其实不单是CCArray，cocos2d-x采用的都是深拷贝的方式，深拷贝和浅拷贝的概念和详解请移步<a href="http://blog.csdn.net/jackystudio/article/details/11553117">这里</a>。它们的区别在于当前对象是否包含了对其他资源的引用。在拷贝机制上采用深拷贝的方式，大大方便了我们对内存的管理，避免因资源的释放导致引用异常。这对于平时在进行一些自定义子类的拷贝处理上还是很有指导意义的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十八】仿《中国好学霸》文字拖拽和定位]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/28/play-cocos2dx-18/"/>
    <updated>2013-10-28T18:00:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/28/play-cocos2dx-18</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/13287519">http://blog.csdn.net/jackystudio</a></p>

<p>现在各种猜成语猜歌名好学霸之类的游戏火的一塌糊涂。本节就介绍下文字的拖拽和定位。</p>

<h3>1.基本原理</h3>

<p>其实这只是精灵的简单拖拽和坐标的识别而已。当触摸点在精灵的范围内，精灵可以感应拖动，当触摸结束进行位置判断，如果在有效范围内就进行自动定位。</p>

<!-- more -->


<h3>2.实现</h3>

<p><strong>2.1.背景加入和文字精灵的加入</strong>
这里是采用<a href="http://blog.csdn.net/jackystudio/article/details/13014883">这一节</a>所述方式添加中文。</p>

<pre><code>bool AutoSet::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCLayer::init());  
        CCSize visiableSize=CCDirector::sharedDirector()-&gt;getVisibleSize();  

        CCSprite* background=CCSprite::create("AutoSetBk.jpg");  
        background-&gt;setPosition(ccp(visiableSize.width/2,visiableSize.height/2));  
        this-&gt;addChild(background);//添加背景  

        //利用CCDictionary来读取xml  
        CCDictionary* chnStrings = CCDictionary::createWithContentsOfFile("CHN_Strings.xml");  
        const char *hao = ((CCString*)chnStrings-&gt;objectForKey("hao"))-&gt;m_sString.c_str();   

        text=CCLabelTTF::create(hao,"Arial",50);  
        text-&gt;setPosition(ccp(120,160));  
        text-&gt;setColor(ccc3(0,0,0));  
        this-&gt;addChild(text);//添加文本  

        this-&gt;setTouchEnabled(true);//设置触摸可用  

        bRet=true;  
    } while (0);  
    return bRet;  
}  
</code></pre>

<p><strong>2.2.触摸的实现和拖拽的定位</strong></p>

<p>因为3.0版本cocos2d-x的触摸实现已经变更了，所以这里不再赘述，3.0之前的触摸的原理和实现具体可以参见<a href="http://blog.csdn.net/jackystudio/article/details/11860007">这一节</a>。</p>

<p><strong>2.2.1注册触摸事件</strong></p>

<pre><code>void AutoSet::registerWithTouchDispatcher(void)  
{  
    CCDirector *pDirector=CCDirector::sharedDirector();    
    pDirector-&gt;getTouchDispatcher()-&gt;addTargetedDelegate(this,0,true);//单点触摸  
}  
</code></pre>

<p><strong>2.2.2.触摸开始</strong></p>

<pre><code>bool AutoSet::ccTouchBegan(cocos2d::CCTouch *pTouch, cocos2d::CCEvent *pEvent)  
{  
    return true;//返回true表示接收触摸事件  
}  
</code></pre>

<p><strong>2.2.3.触摸过程</strong></p>

<pre><code>void AutoSet::ccTouchMoved(cocos2d::CCTouch *pTouch, cocos2d::CCEvent *pEvent)  
{  
    CCPoint beginPoint = pTouch-&gt;getLocationInView();  //获取触摸位置  
    beginPoint = CCDirector::sharedDirector()-&gt;convertToGL(beginPoint);//坐标转换  
    CCPoint pt=text-&gt;getPosition();  
    CCRect rect=CCRectMake(pt.x-30,pt.y-30,60,60);  
    if (rect.containsPoint(beginPoint))//判断触摸点是否在文字上  
    {  
        CCPoint endPoint=pTouch-&gt;getPreviousLocationInView();//获取触摸的前一个位置    
        endPoint=CCDirector::sharedDirector()-&gt;convertToGL(endPoint);     

        CCPoint offSet =ccpSub(beginPoint,endPoint);//获取offset    
        CCPoint toPoint=ccpAdd(text-&gt;getPosition(),offSet); //获取真正移动位置  
        text-&gt;setPosition(toPoint);//移动文字  
    }  
}  
</code></pre>

<p><strong>2.2.4.触摸结束</strong></p>

<pre><code>void AutoSet::ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent)  
{  
    CCPoint lastPoint = pTouch-&gt;getLocationInView();//获取触摸结束点位置  
    lastPoint = CCDirector::sharedDirector()-&gt;convertToGL(lastPoint);  
    CCRect rect=CCRectMake(330,130,60,60);  
    CCMoveTo* moveto;  
    if (!rect.containsPoint(lastPoint))//如果未在指定区域，还原到初始位置  
    {  
        moveto=CCMoveTo::create(0.1f,ccp(120,160));  
    }  
    else//如果在指定区域，移动到该区域中心  
    {  
        moveto=CCMoveTo::create(0.1f,ccp(360,160));  
    }  
    text-&gt;runAction(moveto);  
}  
</code></pre>

<h3>3.效果图</h3>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_18/1.jpg" alt="" border="0" title="1" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_18/2.jpg" alt="" border="0" title="2" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_18/3.jpg" alt="" border="0" title="3" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_18/4.jpg" alt="" border="0" title="4" /><br></br></div>


<h3>4.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6463261">源码下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十七】cocos2d-x中文显示]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/25/play-cocos2dx-17/"/>
    <updated>2013-10-25T16:53:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/25/play-cocos2dx-17</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/13014883">http://blog.csdn.net/jackystudio</a></p>

<p>cocos2d-x的中文显示其实就是一个UTF-8编码在作怪而已，一种简单的方法就是把文本保存为UTF-8编码即可（注意不是UTF-8 + BOM），建议使用UE，Sublime Text或者EditPlus之类的本文编辑器。这里介绍另一种方法：通过读取xml文件显示中文，这种方法更利于软件的国际化，demo顺便实现了中英文切换。</p>

<!-- more -->


<h3>1.xml文件</h3>

<p>先写好一个xml文件（CHN_Strings.xml）。注意记得要以UTF-8编码保存。格式很简单，一个key对应一个string的键值对。如下：</p>

<pre><code>&lt;dict&gt;  
    &lt;key&gt;language&lt;/key&gt;  
    &lt;string&gt;English&lt;/string&gt;  
    &lt;key&gt;username&lt;/key&gt;  
    &lt;string&gt;偶尔e网事&lt;/string&gt;  
    &lt;key&gt;website&lt;/key&gt;  
    &lt;string&gt;CSDN博客：http://blog.csdn.net/jackystudio&lt;/string&gt;  
&lt;/dict&gt;  
</code></pre>

<h3>2.通过CCDictionary读取xml</h3>

<p>CCDictionary是利用哈希表算法来进行CCObject管理的一个类。这里不再对它的API及内部实现进行说明了。</p>

<p><strong>2.1.创建词典类实例</strong>
[cpp] view plaincopy
CCDictionary *chnStrings = CCDictionary::createWithContentsOfFile(&ldquo;CHN_Strings.xml&rdquo;);</p>

<p><strong>2.2.通过键（key）获取值（value）</strong></p>

<pre><code>const char *username = ((CCString*)chnStrings-&gt;objectForKey("username"))-&gt;m_sString.c_str();  
</code></pre>

<p><strong>2.3.使用value</strong></p>

<pre><code>CCLabelTTF* pLabel = CCLabelTTF::create(username, "Arial", 24);//这里创建一个文本  
pLabel-&gt;setPosition(ccp(origin.x + visibleSize.width/2,origin.y + visibleSize.height - pLabel-&gt;getContentSize().height));  
this-&gt;addChild(pLabel, 1);  
</code></pre>

<h3>3.效果</h3>

<p>这里我用了2个xml，一个是中文，一个是英文，设置了一个菜单，点击即可调用不同的xml进行中英文的切换，效果如下图。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_17/1.jpg" alt="" border="0" title="效果1" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_17/2.jpg" alt="" border="0" title="效果2" /><br></br></div>


<h3>4.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6442201">源码下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【玩转cocos2d-x之十六】滚动字幕和公告]]></title>
    <link href="http://www.jacky.tk/blog/2013/10/24/play-cocos2dx-16/"/>
    <updated>2013-10-24T16:38:00+08:00</updated>
    <id>http://www.jacky.tk/blog/2013/10/24/play-cocos2dx-16</id>
    <content type="html"><![CDATA[<p>原创作品，转载请标明：<a href="http://blog.csdn.net/jackystudio/article/details/12991977">http://blog.csdn.net/jackystudio</a></p>

<p>滚动字幕和公告是游戏中经常使用到的元素，本文大致写一下实现方法，至于例子中具体的坐标值，请不要纠结。。。这和美工关系还是蛮大的。我PS技术太搓了。。。</p>

<h3>1.原理</h3>

<p>其实它们的实现都是简单的通过调用update来更新位置达到的移动效果，和背景滚动有点类似，一旦滚动结束就重置为起点，开始新的滚动。只是为了达到在某个区域内滚动而不至于超出这个区域，有时候会用一些前景图来做遮盖，所以这个时候其实字幕或者公告是有在后面滚动的，但是被遮住了，因此看起来就像是只在某个区域内滚动。以垂直字幕滚动为例说明，如下图。</p>

<!-- more -->




<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_16/1.jpg" alt="" border="0" title="原理" /><br></br></div>


<h3>2.实现</h3>

<p>不要纠结以下各精灵的坐标位置：）</p>

<pre><code>bool CTestLayer::init()  
{  
    bool bRet=false;  
    do   
    {  
        CC_BREAK_IF(!CCLayer::init());  

        CCSize visibleSize=CCDirector::sharedDirector()-&gt;getVisibleSize();  
        CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;addSpriteFramesWithFile("ui_serverlist.plist");  

        //垂直滚动字幕  
        CCSprite* listbase=CCSprite::createWithSpriteFrame(CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;spriteFrameByName("login_listbase.png"));//bottom底图  
        listbase-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2+10));  
        this-&gt;addChild(listbase);  
        text1=CCLabelTTF::create("1.Hi! Welcome to JackyStudio,\nMy Blog is\nblog.csdn.net/jackystudio!\n2.Hi! Welcome to JackyStudio,\nMy Blog is\nblog.csdn.net/jackystudio!\n3.Hi! Welcome to JackyStudio,\nMy Blog is\nblog.csdn.net/jackystudio!\n4.Hi! Welcome to JackyStudio,\nMy Blog is\nblog.csdn.net/jackystudio!","Arial",12);//middle文本  
        text1-&gt;setHorizontalAlignment(kCCTextAlignmentLeft);//左对齐  
        text1-&gt;setAnchorPoint(ccp(0.5,1));  
        text1-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2-55));  
        this-&gt;addChild(text1);  
        CCSprite* fg=CCSprite::create("fg.png");//top前景  
        fg-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/2));  
        this-&gt;addChild(fg);  

        //水平滚动公告  
        CCSprite* textbase=CCSprite::createWithSpriteFrame(CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;spriteFrameByName("login_textbase.png"));  
        textbase-&gt;setPosition(ccp(visibleSize.width/2,50));  
        textbase-&gt;setScaleX(2.5f);  
        this-&gt;addChild(textbase);  
        text2=CCLabelTTF::create("Hi! Welcome to JackyStudio,My Blog is blog.csdn.net/jackystudio!","Arial",12);  
        text2-&gt;setPosition(ccp(visibleSize.width+text2-&gt;getContentSize().width/2,50));  
        text2-&gt;setColor(ccc3(255,0,0));//红色字体  
        this-&gt;addChild(text2);  

        this-&gt;scheduleUpdate();//执行更新  

        bRet=true;  
    } while (0);  
    return bRet;  
}  

void CTestLayer::update(float delta)  
{  
    CCSize visibleSize=CCDirector::sharedDirector()-&gt;getVisibleSize();  

    int newY=text1-&gt;getPositionY()+1;  
    if (newY==500)//如果滚动到这个位置，重置  
    {  
        newY=visibleSize.height/2-55;  
    }  
    text1-&gt;setPositionY(newY);  

    int newX=text2-&gt;getPositionX()-1;  
    if (newX&lt;=-text2-&gt;getContentSize().width/2)//如果滚动到这个位置，重置  
    {  
        newX=visibleSize.width+text2-&gt;getContentSize().width/2;  
    }  
    text2-&gt;setPositionX(newX);  
}  
</code></pre>

<h3>3.效果</h3>

<p>这个效果有点小bug，就是文字覆盖到边框上了，这是因为没有把边框做在top层上导致的，实际使用注意这个问题即可。</p>

<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_16/2.jpg" alt="" border="0" title="字幕滚动和公告" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_16/3.jpg" alt="" border="0" title="字幕滚动和公告" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_16/4.jpg" alt="" border="0" title="字幕滚动和公告" /><br></br></div>


<div align="center"><img src="http://www.jacky.tk/images/Blog/Play_cocos2dx_16/5.jpg" alt="" border="0" title="字幕滚动和公告" /><br></br></div>


<h3>4.源码下载</h3>

<p><a href="http://download.csdn.net/detail/jackyvincefu/6434549">源码下载</a></p>
]]></content>
  </entry>
  
</feed>
